# Description

This MadGraph5_aMC@NLO plugin provides two-loop (and one-loop) matrix elements with exact quark mass dependence to the loop-induced scattering partonic processes: 

* `g g > H g`
* `g q(qbar) > H q(qbar)`
* `q qbar > H g`

and used in ref. [hep-ph:2206.10490](https://arxiv.org/pdf/2206.10490.pdf) for the computation of the NLO QCD accurate prediction of the Higgs transverse momentum, including exactly the dependence on the quark masses circulating in the loops.

This implementation builds upon an earlier version of this plugin available at:

https://bitbucket.org/aschweitzer/mg5_higgs_ew_plugin/src/master/

which was designed for computing the mixed QCD-EW three-loop contributions to `p p > H` and two-loop contributions to `p p > H j` ([hep-ph:2010.0945](https://arxiv.org/pdf/2010.09451.pdf)).
While this version of the plugin still *in principle* also offers this mixed QCD-EW implementation, it has not been re-validated.
We therefore still refer to the reader interested in these mixed QCD-EW amplitudes to follow the link above and installation instructions therein for generating such matrix elements.

In what follows instead, we will focus instead on the aforementioned two-loop Higgs-jet associated production amplitudes with exact quark mass dependence.
One reason for this separation is that the mixed QCD-EW amplitudes were computed using a private implementation of the series expansion method for solving differential equations, whereas this new implementation is leveraging the public tool `DiffExp`.

# Installation

* This plugin requires a `Python2` version of `MadGraph5_aMC@NLO`, and you should therefore first install `MG5aMC v2.7.3` (https://launchpad.net/mg5amcnlo/2.0/2.7.x/+download/MG5_aMC_v2.7.3.tar.gz).
* This plugin requires `Mathematica v 12.1.1.0+` for correctly running `DiffExp`.
* Clone this repository into the folder `PLUGIN`  located under root of your `v2.7.3` `MG5aMC` installation.
* Download the additional resources (boundary conditions) from:
<TODO:MakeSureThisIsALongTermHost> (filesize: `~15 GB`)
and extract them into a folder named `GridPrecomputed` in `<MG_root>/PLUGIN/linlo_pp_hj/ComputationFormFac_PPHJ_Shared/Dependencies/Data/` (this can take time as this tarball contains about `250k` files).

# Basic usage

The two-loop amplitudes are implemented as an effective UFO vertex, thus allowing the matrix elements to be generated by MG5aMC like for any other tree-level process.
Of course, the couplings of this effective vertex are not static, but instead the two-loop form factor with their exact dependency on the kinematic Mandelstamm variables `s` and `t`, as well as quark masses `m_t` and `m_b`, and the Higgs mass `m_H`.
The plugin will make sure to adjust the Fortran output of the matrix element generated so that these "dynamical" couplings are appropriately recomputed for each phase-space point.

The two-loop matrix elements can be generated using and example generation card provided with the plugin:

`python2.7 ./bin/mg5_aMC --mode=linlo_pp_hj ./PLUGIN/linlo_pp_hj/gen_LINLO_pphj_2L.linlo`

and similarly for the one-loop squared matrix-element:

`python2.7 ./bin/mg5_aMC --mode=linlo_pp_hj ./PLUGIN/linlo_pp_hj/gen_LINLO_pphj_1L.linlo`

which will create the process outputs `VALIDATION_1L_TEST_OUTPUT` and `VALIDATION_2L_TEST_OUTPUT` respectively.

Next, in order to actually evaluate the matrix elements generated with the above, proceed as follows (e.g. for the two-loop `gg > Hg` case here):

1) First make sure to create a new empty fifo file for the communication between `Fortran` and `Mathematica` with:

`rm -f /tmp/mathematica_input.fifo; mkfifo /tmp/mathematica_input.fifo`

2) Change directory to your process of interest, e.g.:

`cd VALIDATION_2L_TEST_OUTPUT/SubProcesses/P10_gg_hg`

3) Compile and run the standalone fortran evaluator:

`make check && ./check`

at this point, the `Fortran` matrix evaluation will hang, since it now wrote its query for the form factors evaluation in the `/tmp/mathematica_input.fifo` file, and is now awaiting the result.
In order to have these queries processed, we now need to start the Mathematica `DiffExp` worker, as specified in the next step.

4) The Mathematica `DiffExp` worker should be started within the following directory:

`cd <MG_root>/PLUGIN/linlo_pp_hj/ComputationFormFac_PPHJ_GGHG/mathematicaRoutines`

and started with:

`wolframscript gghg_coefs_fifo.wls mathematica_input.fifo default default /tmp /tmp/DiffExp_log.txt`

it should then automatically pick up the "job" specified in `/tmp/mathematica_input.fifo` and start computing the form factors.
Once they are returned, you should see the fortran program launched earlier with `./check` return, with the following output to:

```
PUT FORTRAN OUTPUT HERE ONCE WORKING
```

Please note that this result corresponds only to `2*Re( Fin(A2L) * Conjugate( Fin(A1L) ) )`, where `Fin(A1L)` (resp. `Fin(A2L)`) is the finite part of the renormalised, but not IR-subtracted, 1-loop (resp. 2-loop) amplitude.
In order to get the complete finite part of the squared matrix element, one must make sure to also include cross-terms such as the pole of the 2-loop amplitudes multiplied by the order epsilon of the 1-loop amplitude (see the `Advanced usage` section).

Finally, you can find in the file `<MG_ROOT_DIR>/PLUGIN/linlo_pp_hj/pphj_validation_results.txt` one benchmark result for each of the four processes in both `VALIDATION_1L_TEST_OUTPUT` and `VALIDATION_2L_TEST_OUTPUT` in order to validate your installation.

# Advanced usage of the Fortran matrix elements

The `./PLUGIN/linlo_pp_hj/gen_LINLO_pphj_2L.linlo` generation card contains the following:

```
[...]
# Enumerate the partonic processes you are interested in:
add process g g  > h g GGHG1LQCD<=1 GGHG2LQCD<=1 PPHJ^2==2 GGHG1LQCD^2==1 GGHG2LQCD^2==1 @10
add process d d~ > h g QQHG1LQCD<=1 QQHG2LQCD<=1 PPHJ^2==2 QQHG1LQCD^2==1 QQHG2LQCD^2==1 @20
add process d g  > h d QQHG1LQCD<=1 QQHG2LQCD<=1 PPHJ^2==2 QQHG1LQCD^2==1 QQHG2LQCD^2==1 @30
add process g d  > h d QQHG1LQCD<=1 QQHG2LQCD<=1 PPHJ^2==2 QQHG1LQCD^2==1 QQHG2LQCD^2==1 @40

# Now output the matrix element code to disk
output standalone_ggHg VALIDATION_2L_TEST_OUTPUT
```

The important aspect of this generation is the definition of the process, e.g.:
```
add process g g  > h g GGHG1LQCD<=1 GGHG2LQCD<=1 PPHJ^2==2 GGHG1LQCD^2==1 GGHG2LQCD^2==1 @10
```
where the squared order couplings specification are crucial in order to specify the kind of multi-loop amplitudes one is interested in generating. In the example above, `PPHJ^2==2` specifies that exactly two insertion of an effective vertex implementing a (multi-)loop computation of the type `PPHJ` should be inserted.
Then `GGHG1LQCD<=1 GGHG1LQCD^2==1` specifies that exactly one *one*-loop effective vertex must be considered (either as amplitude, or complex-conjugated amplitude), and similarly `GGHG2LQCD<=1 GGHG2LQCD^2==1` specifies that exactly one *two*-loop effective vertex must be considered.
This type of generation is flexible, because in this way, one could for example consider attaching any on-shell higgs decay to this matrix element, simply by modifying the process specified.

Once the process is generated, both model parameters and the parameters steering the multi-loop effective vertex computation are all specified through the model param card, e.g. through `VALIDATION_2L_TEST_OUTPUT/Cards/param_card.dat`.
The model parameters are the usual Standard Model ones in the `SLHA` conventions (note that the renormalisation scale can be specified using the `MU_R` parameter), but the card now contains a couple of new `SLHA` blocks specific to the multi-loop computation and described below:
```
###################################
## INFORMATION FOR PPHJ
###################################
Block pphj 
  10010 5.000000e+00 # PPHJ_nf 
  10011 -1.000000e+00 # PPHJ_DEBUG 
  10012 -1.000000e+00 # PPHJ_RUN_ID 
  10013 -1.000000e+00 # PPHJ_INPUT_ID 
  10014 -1.000000e+00 # PPHJ_BATCH_ID 

###################################
## INFORMATION FOR GGGH2LQCD
###################################
Block gggh2lqcd 
[... ignore the 'GGGH2LQCD_ForFac' params ... ]
  10410  1.0+00 # GGGH2LQCD_ytqcd 
  10411 -1.0e+00 # GGGH2LQCD_ytmb 
  10412  1.0e+00 # GGGH2LQCD_ytmt 
  10413 -1.0e+00 # GGGH2LQCD_ybqcd 
  10414 -1.0e+00 # GGGH2LQCD_ybmb 
  10415 -1.0e+00 # GGGH2LQCD_ybmt 
  10416  0.0e+00 # GGGH2LQCD_eps_order 
  10417  0.0e+00 # GGGH2LQCD_eval_mode 
```
(Note: in the default card you can see trailing random digits; these are just for making sure that MadGraph does not simplify/combine parameters when loading the model, so these trailing digits can be ignored)

Depending on the context, these parameters will be interpreted as boolean (`<=0.` is `false` and `>0` is `true`) or integers (rounded to *nearest* integer).
Note that these parameters can be modified without having to recompile any code since they will be read from the card at run time.
We provide here some details regarding these plugin-specific parameters:

* `PPHJ_nf` : Controls the value of `nf` to be considered within the (multi-)loop computation of the effective vertex form factors.
* `PPHJ_DEBUG` : Enables debugging information in the communication between `Fortran` and `Mathematica`.
* `PPHJ_RUN_ID`,`PPHJ_INPUT_ID`,`PPHJ_BATCH_ID` : Provides finer control in the `fifo` pipes use for communicating to the `wolfram` `DiffExp` workers. 

The role of the last three parameters above is made clearer when reading the following snippet of e.g. `VALIDATION_2L_TEST_OUTPUT/Source/MODEL/fortran_bridge_pphjGGHGQCD2L.cpp`:
```c++
    std::ostringstream mm_file_path_ss;
	if (input_ID>0) {
		if (pphj_batch_id < -1) {
			mm_file_path_ss<<"<MG_ROOT_DIR>/PLUGIN/linlo/ComputationFormFac_PPHJ_GGHG/mathematicaRoutines/mathematica_input_"<<input_ID<<".fifo";
		} else if (pphj_batch_id == -1) {
			mm_file_path_ss<<"/tmp/mathematica_input_"<<input_ID<<".fifo";
		} else {
			mm_file_path_ss<<"/tmp/batch_"<<pphj_batch_id<<"/mathematica_input_"<<input_ID<<".fifo";
		}
	} else {
		if (pphj_batch_id < -1) {
			mm_file_path_ss<<"<MG_ROOT_DIR>/PLUGIN/linlo/ComputationFormFac_PPHJ_GGHG/mathematicaRoutines/mathematica_input.fifo";
		} else if (pphj_batch_id == -1) {
			mm_file_path_ss<<"/tmp/mathematica_input.fifo";
		} else {
			mm_file_path_ss<<"/tmp/batch_"<<pphj_batch_id<<"/mathematica_input.fifo";
		}
	}
```
Depending on your parallelisation setup, you may find it useful to be able to organise the various stream of requests from your worker using these three control variables `PPHJ_RUN_ID`,`PPHJ_INPUT_ID`,`PPHJ_BATCH_ID`.

Then in the block `GGGH2LQCD` (and similarly for `GGGH1LQCD`, `QQGH2LQCD` and `QQGH1LQCD`) we find parameters controlling what loop contributions to consider.
A first family of parameters are named `(GG|QQ)GH(1|2)LQCD_(yt|yb)(qcd|mb|mt)` and specifies what corrections must be included.
`yt` and `yb` specifies the fermion specie connected to the Higgs, then `mb` indicates QCD correction to that family involving a closed bottom quark loop, `mt` involving a closed top quark loop and `qcd` all other types of corrections.

Finally, the last two parameters are:

* `GGGH2LQCD_eps_order` specifies which coefficient of the Laurent series in epsilon to return.
* `GGGH2LQCD_eval_mode` specifies how the form factors must be computed (`false` means exact evaluation and `true` means interpolation (not recommended))

It is useful to be able to adjust these parameters at run time, for example when making successive calls for different renormalisation scales or coefficients of the Laurent series (at minimal cost thanks to a built-in caching system).
To this end, the following set of Fortran subroutine in `<PROCESS_OUTPUT_DIR>/Source/couplings.f` are provided and will be exposed in the static library generated so that they can be called by the user at any point:
```fortran
C Allows to dynamically adjust the renormalisations scale and alpha_s
      SUBROUTINE PROC_10_UPDATE_AS_PARAM2(MU_R2,AS2)
[...]

C Allows to dynamically adjust some model parameters
      SUBROUTINE PROC_10_PROC_10_UPDATE_LINLO_COUPLINGS(
     &     IN_MB, IN_MT, IN_MH, IN_YMB,IN_YMT, IN_MW, IN_MZ,
     &      IN_WT, IN_WH, IN_WW, IN_WZ, IN_AEWM1, IN_GF, IN_PPHJ_RUN_ID
     & )
[...]

C Allows to dynamically adjust the target epsilon order to compute for each effective vertex
      SUBROUTINE PROC_10_PROC_10_UPDATE_LINLO_EPSORD(
     &  GGGH1,QQGH1,GGGH2,QQGH2
     &     )
[...]
```

A library containing all necessary dependences can be generated by running:
```
LIBNAME=LINLO make libLINLO.a
```
in the `<PROCESS_OUTPUT_DIR>/lib` directory, which will produce the `<PROCESS_OUTPUT_DIR>/lib/libLINLO.a` library that is ready to be interfaced to other codes.

# Advanced usage of the wolfram `DiffExp` worker

As stated above, the `DiffExp` worker responsible for evaluating the form factors is started from within `<MG_root>/PLUGIN/linlo_pp_hj/ComputationFormFac_PPHJ_GGHG/mathematicaRoutines` with the following arguments:

`wolframscript gghg_coefs_fifo.wls <mathematica_input_file_name> <ExactModeDirectory> <IndexingFile> <PATH_TO_DIRECTORY_CONTAINING_mathematica_input_file> <PathToDiffExpLogFile>`

where the last four arguments can be set to the value `default` if you do not wish to specify them.
The arguments `<ExactModeDirectory> <IndexingFile>` specify the location of the cache directory where form factors and integrals computed by `DiffExp` will be stored for later use if the same phase-space point is queried again (e.g. with different observables, renormalisation scale or epsilon order requested).
By default, this folder is set to `<MG_root>/PLUGIN/linlo_pp_hj/ComputationFormFac_PPHJ_Shared/Dependencies/Data/ExactMode`.

Additional global parameters regarding the steering of the `DiffExp` worker can be modified in the file `<MG_root>/PLUGIN/linlo_pp_hj/ComputationFormFac_PPHJ_Shared/BaseConfiguration.wls`. Most important are:
```mathematica
(* Constants related to the renormalization scheme. *)
KyOSReplace = 0; (* Set to 1 for OS scheme *)
KmOSReplace = 0; (* Set to 1 for OS scheme *)

(* Number of fifo listeners per instance. *)
FIFOListeners = 1;
ParallelMode = "Multi"; (* Single: listen to a single mathematica_input.fifo file. Multi: listen to multiple mathematica_input_X.fifo files, each subkernels essentially behaving like a separate process. *)
```
where setting `FIFOListeners` larger than `1` allows for enabling internal parallelisation within that worker (either listening from a single `fifo` stream or multiple ones).