(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Copyright (C) 2020 Martijn Hidding *)

(* DiffExp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>. *)

(* This software is maintained on https://gitlab.com/hiddingm/diffexp *)

BeginPackage["DiffExp`"];

Print["Loading DiffExp version 1.0.8"];
Print["For questions, email: martijn.hidding@physics.uu.se"];
Print["For the latest version, see: https://gitlab.com/hiddingm/diffexp"];

\[Epsilon]::usage="Symbol representing the dimensional regulator.";
eps::usage="Alternative symbol for the dimensional regulator, which is converted into \[Epsilon]."
Logx::usage="Symbol representing Log[x].";
\[Theta]p::usage="Symbol representing HeavisideTheta[x].";
\[Theta]m::usage="Symbol representing HeavisideTheta[-x].";
CurrentConfiguration::usage="CurrentConfiguration[] returns the current configuration values.";
IntegrateSystem::usage="
IntegrateSystem[line_List] can be used to obtain the general series solutions of the integrals along the line given in the second argument. \n
IntegrateSystem[bcs_List, line_List] can be used to obtain the series solutions of the integrals along the line given in the second argument. The first argument should be a set of boundary conditions, obtained as the output of the function PrepareBoundaryConditions[...], or the output of TransportTo[...].
";
LoadConfiguration::usage="LoadConfiguration[l_List] can be used to parse configuration options to DiffExp. The configuration options should be given in the form \"option -> value\". Values that are omitted are assigned a standard value. \n 

The possible options are: AccuracyGoal, ChopPrecision, DeltaPrescriptions, DivisionOrder, EpsilonOrder, ExpansionOrder, IntegrationStrategy, LineParameter, LogFile, MatrixDirectory, RadiusOfConvergence, SegmentationStrategy, UseMobius, UsePade, Variables, WorkingPrecision, Verbosity.
";
UpdateConfiguration::usage="UpdateConfiguration[l_List] or UpdateConfiguration[l__Rule] can be used to update configuration options. The configuration options should be given in the form \"option -> value\". See LoadConfiguration[...] for more information.";
PrepareBoundaryConditions::usage="PrepareBoundaryConditions[bcs_List, line_List] can be used to prepare boundary conditions for use with the functions IntegrateSystem[...] or TransportTo[...]. The first argument should contain the boundary conditions, while the second argument should contain a point or line specifying an asymptotic limit in phase-space, in which the boundary conditions are given. DiffExp recognizes whether the argument is a line or a point, by checking whether it depends on the line parameter. The boundary conditions can be given in three ways: \n

1. A closed-form expression in \[Epsilon]. \n
2. A list of coefficients for each order in \[Epsilon], where the first list element corresponds to order \!\(\*SuperscriptBox[\(\[Epsilon]\), \(0\)]\). \n
3. The string \"?\", which instructs DiffExp not to consider boundary conditions for the integral. This option is useful for when dealing with coupled integrals in an asymptotic limit, where the boundary conditions for a subset of the integrals may fix the remaining ones.

If the boundary conditions contain multivalued functions they should be provided in such a way that the positive direction of the line across which the limit is taken points along the standard (Mathematica branch) of the multivalued function. For more information, please see the paper.
";
ToPiecewise::usage="ToPiecewise[segmentdata_List, pade_:False] takes as input the output of the function TransportTo[...], given that the latter has been run with the argument save_ equal to True. The output of ToPiecewise[...] is an (n\[Cross]m)-matrix, where n is the number of basis integrals and where m is equal to the value of the option EpsilonOrder plus one. Each entry is a Piecewise mathematica object, which is a function of the line parameter of the line that was given to TransportTo[...]. The output of ToPiecewise may be used for numerical evaluation of the results at arbitrary points along the line, or for plotting purposes. \n

The argument pade_ determines whether the Piecewise functions are composed out of the Pad\[EAcute] approximants of the solutions along the line segments, or out of the series solutions. If TransportTo[...] was called with the configuration option UsePade set to False, there should not be a significant difference in precision by enabling Pad\[EAcute] approximants here. ";
TransportTo::usage="TransportTo[bcs_List, line_List, to_:1, save_:False] performs the transportation of boundary conditions to arbitrary (real-valued) points in the phase-space of kinematic invariants and masses. The first argument should be a set of boundary conditions, obtained as the ouput of the function PrepareBoundaryConditions[...], or the output of TransportTo[...]. If the second argument is a line (i.e. it depends on the line parameter), the results will be transported to the endpoint (line /. x \[Rule] to). If the second argument argument is a point instead, DiffExp will consider the line \"x*line + (1-x)*start\", where start is the point at which the boundary conditions were prepared using PrepareBoundaryConditions[...]. The argument save_ determines whether the expansions along individual line segments should be saved and returned in the output. If it is set to True, the output of TransportTo[...] may be passed to the function ToPiecewise[...], which combines the results of all line segments together into a single function. \n

The output of TransportTo[...] depends on the options with which DiffExp is configured. If the argument save_ is set to False, the output is a list consisting of the form {point, results, errors}. The first list element is the point in phase-space at which the results were evaluated. The second and third element of the list are both (n\[Cross]m)-matrices, where n is the number of basis integrals and where m is equal to the value of the option EpsilonOrder plus one. If the argument save_ is set to True, the output of TransportTo[...] has instead the form {{point, results, errors}, segmentdata}, where segment data is a list which encodes the expansions obtained along individual line segments.
";
ChopPrecision::usage="Indicates the number off zeros after the decimal point after which terms should be set to 0 in intermediate computations.";
DeltaPrescriptions::usage="A list of polynomials in the kinematic invariants and masses, each of which should contain an explicit factor \[PlusMinus]I\[Delta]. The zeros of the polynomials should describe singularities such as physical threshold singularities, or branch points of square roots.";
DivisionOrder::usage="This option determines the inverse distance to the nearest singularity at which the line segments are evaluated, when the predivision strategy is used.";
EpsilonOrder::usage="An integer specifying the highest order in the dimensional regulator \[Epsilon] in which the integrals should be computed.";
ExpansionOrder::usage="Specifies the maximum power of the line parameter that should be kept in intermediate series expansions. At intermediate steps the expansions might be multiplied by poles, and the final results may be provided at a lower expansion order.";
LineParameter::usage="The line parameter used for parsing lines to DiffExp.";
LogFile::usage="Location of a log file on which to write all output of the current session.";
MatrixDirectory::usage="The location of a directory on the file system which contains the partial derivative matrices \!\(\*SubsuperscriptBox[\(A\), \(s\), \((k)\)]\). The files should be named according to the convention ds_k.m, where s is the external scale, and k is the order in \[Epsilon]. A special file d_1.m may be provided for a canonical polylogarithmic family, which should contain a matrix whose entries are Q-linear combinations of logarithms (the alphabet letters.)";
RadiusOfConvergence::usage="This option has the effect of rescaling the line parameter of each line segment, so that the minimal radius of convergence is given by its value. Higher values may help to combat fastly growing series coefficients.";
SegmentationStrategy::usage="This option determines which segmentation strategy is used. The possible values are \"Dynamic\" and \"Predivision\".";
IntegrationStrategy::usage="Determines how the differential equations are solved. The possible values are \"Default\", and \"VOP\". The strategy \"VOP\" is generally a bit slower for solving coupled integrals, but works along degenerate lines. Please see the paper for more details.";
UseMobius::usage="This option determines whether the line segments are obtained by linear transformations or by M\[ODoubleDot]bius transformations.";
UsePade::usage="Determines whether Pad\[EAcute] approximants are used while transporting boundary conditions.";
Verbosity::usage="Determines the level of printed output. The default level is 1 and the maximum level is 3. When running inside a Mathematica notebook, lower verbosity levels are generally recommended. For shell-scripts higher verbosity levels might be preferred.";

Begin["`Private`"];

(* Default configuration *)
DefaultConfiguration={
AccuracyGoal->"?",
"AccuracyGoalValidate"->"Before",
ChopPrecision->250,
"CrosscheckLevel"->0,
DeltaPrescriptions->{},
DivisionOrder->3,
EpsilonOrder->4,
"EstimateError"->"Fast",
ExpansionOrder->50,
"InvWronskSolver"->"Auto",
"KeepMatrixExpansions"->False,
"LinearSolveChopPrecision"->250,
LineParameter->Global`x,
MatrixDirectory->"",
RadiusOfConvergence->1,
"SaveExpansionsCompress"->False,
"HomogeneousSolve"->"Expand",
SegmentationStrategy->"Predivision",
IntegrationStrategy->"Default",
UseMobius->False,
UsePade->False,
Variables->{},
Verbosity->1,
"VerbosityDebug"->0,
WorkingPrecision->500
}//Association;

DiffExpExtensions={};

eps:=\[Epsilon];

CurrentConfiguration[]:=KeySelect[DiffExpConfiguration,MemberQ[{
AccuracyGoal,ChopPrecision,DeltaPrescriptions,DivisionOrder,EpsilonOrder,ExpansionOrder,LineParameter,MatrixDirectory,RadiusOfConvergence,SegmentationStrategy,IntegrationStrategy,UseMobius,UsePade,Variables,Verbosity,WorkingPrecision
},#]&];

If[!ValueQ[DiffExpConfiguration],
DiffExpConfiguration=DefaultConfiguration;
];
FEC:=DiffExpConfiguration;

ChopPrecisionVal:=FEC[ChopPrecision];
LinearSolveChopPrecisionVal:=FEC["LinearSolveChopPrecision"];
CrosscheckChopPrecision:=30;
ExternalScalesVal:=FEC[Variables];
LineParameterVal=FEC[LineParameter];
x=FEC[LineParameter];
MatrixDirectoryVal:=FEC[MatrixDirectory];
EpsilonOrderVal:=FEC[EpsilonOrder];
FEAccuracyGoal:=FEC[AccuracyGoal];
FEWorkingPrecision:=FEC[WorkingPrecision];
DeltaPrescriptionsVal:=FEC[DeltaPrescriptions];
UseMobiusVal:=FEC[UseMobius];
RadiusOfConvergenceVal:=FEC[RadiusOfConvergence];
DivisionOrderVal:=FEC[DivisionOrder];

If[!ValueQ[ExpansionOrderVal],ExpansionOrderVal=50;];
If[!ValueQ[MaxCouplingOrder],MaxCouplingOrder=1;];

If[!ValueQ[DEqnMatricesFactored],
DEqnMatricesFactored=Association[{}];
];
If[!ValueQ[DEqnMatricesExpanded],
DEqnMatricesExpanded=Association[{}];
];
If[!ValueQ[NumIntegrals],
NumIntegrals=0;
];

(* State variables *)
AnalyticContinuationReplacements={};
AnalyticContinuationReplacementsAssociation=Association[{}];
UserDeltaPrescriptions={};
SquareRootPrescriptionsAdded[]:={#,1}&/@Complement[Expand[DEqnSquareRoots],Flatten@Expand@{UserDeltaPrescriptions[[All,1]],-UserDeltaPrescriptions[[All,1]]}];
DEqnSquareRoots={};
CurrentSingularityWasAddedFromSquareRoot=False;
CurrentSingularityHasIDeltaPrescription=False;
AnalyticContinuationFailed=False;
MultivaluedFail=False;

(* Constants for internal purposes. These should normally not have to be changed. *)
CrosscheckFlags={
"FrobeniusSolutions"->1,
"MatrixDelta"->1,
"Wronskians"->1,
"WronskInv"->0,
"PeriodMatrix"->1,
"GeneralSolutionMatrix"->2,
"GeneralSolution"->1,
"VariationOfParameters"->1,
"SingularityCheck"->0
};
CurrCrosscheckFlags={};

ISeriesChangeCoefficient=2;
IMaxLogOrder=IMaxLogOrderDefault=1;
ICheckMultivaluedChop=5;
ICrossCheckPrintResultOrder=5;
ICrossCheckVerifyResultOrder=5;
ISafetyDigits=2;
ISafetyExpansionSubtract=5;
IExpansionOrdersAveraging=3;
IExpansionOrderIncrease=10;
IExpansionOrderDecrease=10;
IExpansionOrderIncrease2=25;(* When AccuracyGoalValidate is set to "After" *)
IDigitsSurplusDecreaseExpansionOrder=3;
ICurrEvalErrorSeriesDecrease:=Ceiling[0.7(MaxCouplingOrder)]+2;
IDecreaseOrderByErrorPrecise=MaxCouplingOrder;
IMinExpansionOrder=10;

(* Functions for printing. *)
PrintDebug[args__][lev_]:=If[lev<=FEC["VerbosityDebug"],Print[Sequence@@ConstantArray["   ",Max[lev-1,0]],"DiffExp Debug: ",args]];
PrintInfo[args__][lev_]:=If[lev<=FEC[Verbosity],Print[Sequence@@ConstantArray["   ",Max[lev-1,0]],"DiffExp: ",args]];
PrintWarning[args__]:=Print["DiffExp Warning: ",args];
ReportError[mes__]:=(Print["DiffExp Error: ",mes];Abort[];);
ReportError[mes__,False]:=Print["DiffExp Error: ",mes];

(* Various small functions *)
SetAttributes[{SApply,SN,SExpand,SN,SSN,SMultiply,SEval,SEval1,SEval2,DecreaseSeriesOrderBy,SeriesCoefficientMinus,SplitTimes,ApplyAnalyticContinuation},Listable];
AllSameQ[l_,b_]:=If[Length[l]>0,SameQ[l]&&l[[1]]===b,True];
CA=ConstantArray;
GetCases[expr_,case_]:=expr//Cases[{#},case,Infinity]&//DeleteDuplicates//Sort;
DependsQ[a_,b_]:=Length[GetCases[a,b]]>0;
ZeroQ[a_]:=a===0;
R=ReplaceAll;
FirstOrNull[l_]:=If[l==={},Null,First[l]];
FindPivots[Matrix_]:=DeleteCases[Flatten[FirstOrNull[Position[#,a_/;a!=0]]&/@Matrix],Null];
SplitTimes[Expr_]:=If[Expr[[0]]===Times,List@@Expr,{Expr}];
MaxLogxPower[ex_]:=Append[GetCases[ex//SExpand,Logx^(k_:1):>k],0]//Max;
LogxCoeff[Ser_,Which_]:=If[Which===0,SApply[(#/.Logx->0)&,Ser],SApply[(Coefficient[#,Logx^Which])&,Ser]];
LogxCoeffNS[Ser_,Which_]:=If[Which===0,Ser/.Logx->0,Coefficient[Ser,Logx^Which]];
LogxCoeffList[Ser_]:=Block[{maxpow=MaxLogxPower[Ser]},Table[LogxCoeff[Ser,ord],{ord,0,maxpow}]]
PChop:=Chop[#,10^-FEC[ChopPrecision]]&;
LSPChop:=Chop[#,10^-FEC["LinearSolveChopPrecision"]]&;
CPChop:=Chop[#,10^-CrosscheckChopPrecision]&;
IsPoint[line_]:=!DependsQ[line//Values,x];
IsLine[line_]:=!IsPoint[line];
SApply[f_,0]:=0;
SApply[f_,a_SeriesData]:=MapAt[f,a,3];
SApply[f_,a_]:=((*ReportError["Internal error: SApply is applied to a term that is not a series: ",a//N];*)f[a]);
SExpand[0]:=0;
SExpand[a_SeriesData]:=SApply[PChop@*Expand,a];
SExpand[a_]:=Expand[a];
SN:=SApply[N,#]&;
SSN:=SN;
SMultiply[a_,b_]:=SExpand[a] SExpand[b]//SExpand;
SeriesCoefficientMinus[a_SeriesData,k_:1]:=a[[3]][[Max[-k,-Length[a[[3]]]]]]x^((a[[5]]-k)/a[[6]]);
SeriesCoefficientMinus[a_,k_:1]:=0;
ApplyAnalyticContinuation[s_SeriesData]:=Series[Normal[s]/.AnalyticContinuationReplacements,{x,0,Floor[s[[5]]/s[[6]]]}];
SplitSum[Expr_]:=If[Expr[[0]]===Plus,List@@Expr,{Expr}];
SafeReplaceSeries11[a_SeriesData,b_]:=Block[{ex=Normal[a],ex2},
ex2=Series[(ex/.b),{x,0,Ceiling[a[[5]]/a[[6]]]}];
ex2+O[x]^(a[[5]]/a[[6]])
];
SafeReplaceSeries11[a_List,b_]:=SafeReplaceSeries11[#,b]&/@a;
SafeReplaceSeries11[a_,b_]:=a/.b;

MatrixMultiplySExpand[MatA_,MatB_]:=Module[{Dim1=Dimensions[MatA],Dim2=Dimensions[MatB]},
If[!(Dim1[[2]]===Dim2[[1]]),
Global`DebugData={MatA,MatB};
ReportError["Matrix dimensions don't match."];
];

Table[
SExpand@Sum[SMultiply[MatA[[iind,kind]],MatB[[kind,jind]]],{kind,Dim1[[2]]}]
,{iind,Dim1[[1]]},{jind,Dim2[[2]]}
]
];
MatrixPowerSExpand[a_,0_]:=Block[{dim=a//Dimensions},If[!(dim[[1]]===dim[[2]]),ReportError["Matrix is not square!"];];IdentityMatrix[dim[[1]]]];
MatrixPowerSExpand[a_,n_]:=Nest[MatrixMultiplySExpand[a,#]&,a,n-1];

SetAttributes[DiffExpSeries,Listable];
DiffExpSeries[Ser_,ord_]:=SeriesAlways[Ser//Quiet[N[#,FEWorkingPrecision]]&,{x,0,ord}];
SeriesAlways[term_,{a_,b_,c_},ex_:1]:=If[DependsQ[term,a],
Series[term,{a,b,c},Assumptions->x>0]
,
\!\(\*
TagBox[
StyleBox[
RowBox[{"SeriesData", "[", 
RowBox[{"a", ",", "b", ",", 
RowBox[{"{", "term", "}"}], ",", "0", ",", 
RowBox[{
RowBox[{"c", " ", "ex"}], "+", "1"}], ",", "ex"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)
];
DiffExpSeries[Ser_]:=DiffExpSeries[Ser,ExpansionOrderVal];

LeadingCoefficientSeries[Ser_,AddTo2_:1]:=Module[{Ser1,Ser2,AddTo,Den1,Den2,tmp},
If[!DependsQ[Ser//Normal,x],
Ser+O[x]^(1/AddTo2)
,
Assuming[x>0,
Ser1=Ser/.x->(x+O[x]^2);
Ser2=Ser1/.a_List:>Take[a,1];

Den1=Association[#[[1]]->#[[2]]&/@(Ser1[[6]]//FactorInteger)];
Den2=Association[#[[1]]->#[[2]]&/@(AddTo2//FactorInteger)];
AddTo=Times@@KeyValueMap[#1^#2&,Merge[{Den1,Den2},Max]];

tmp=Ser1[[4]]/Ser1[[6]]+1/AddTo;
Ser2+SeriesData[x,0,List[],tmp//Numerator,tmp//Numerator,tmp//Denominator]
]
]
];

SeriesMinPower[Ser_]:=Ser[[4]]Ser[[6]];
SeriesMaxPower[Ser_]:=Ser[[5]]Ser[[6]];

DecreaseSeriesOrderBy[a_,k_:1]:=Block[{tmp},If[
a[[0]]===SeriesData,
tmp=a;
tmp[[5]]=tmp[[5]]-k tmp[[6]];
tmp,
a
]
];

IntervalOverlapQ[intv1_,intv2_]:=!(IntervalIntersection[Interval[intv1],Interval[intv2]]===Interval[]);
IntervalIntersec[intv1_,intv2_]:=IntervalIntersection[Interval[intv1],Interval[intv2]][[1]];
IntervalContainsQ[intv_,point_]:=intv[[1]]<=point<=intv[[2]];

(* --- Bulk of the code starts here --- *)
GetMobius[{-\[Infinity],zmid_,\[Infinity]}]:=x-zmid;
GetMobius[{zmin_,zmid_,\[Infinity]}]/;zmin!=-\[Infinity]:=(zmid+x zmid-2 x zmin)/(1-x)//Simplify;
GetMobius[{-\[Infinity],zmid_,zmax_}]/;zmax!=\[Infinity]:=(2 x zmax+zmid-x zmid)/(1+x)//Simplify;
GetMobius[{zmin_,zmid_,zmax_}]/;zmax!=\[Infinity]&&zmin!=-\[Infinity]:=-((-1+x) zmid zmin+zmax (zmid+x zmid-2 x zmin))/((-1+x) zmax+zmin+x (-2 zmid+zmin))//Simplify;
GetMobius[{zmin_,\[Infinity],zmax_}]/;zmax!=\[Infinity]&&zmin!=-\[Infinity]:=(zmin (-1+x)+zmax (1+x))/(2 x);

(* Pade approximants *)
GetPade[0]=0;
GetPade[a_?NumericQ]:=a;
GetPade[a_SeriesData]:=Block[
{
$MinPrecision=FEWorkingPrecision,
MaxOrd={Floor[((a[[5]]-a[[4]])/a[[6]]+1)/2],Floor[((a[[5]]-a[[4]])/a[[6]]+1)/2]},
MaxLogOrder=MaxLogxPower[a],
TempPad
},

Sum[
Logx^ind (
(Quiet[
TempPad=PadeApproximant[Chop[#,10^-ChopPrecisionVal],{x,0,MaxOrd}];
If[Length[GetCases[TempPad,PadeApproximant[__]]]>0,
PrintWarning["Error in Pade approximant of ",#//N,". Evaluating normally."][1];
PChop@#,
TempPad
]
])&@(Normal@LogxCoeff[a,ind])
)
,{ind,0,MaxLogOrder}]
]

(* Functions for evaluating series. *)
SEval1[a_SeriesData]:=If[FEC[UsePade]===True,GetPade[a],Normal[a]];
SEval1[0]:=0;
SEval1[a_/;NumericQ[a]]:=a;
SEval2[a_,at_]:=Block[{$MinPrecision=FEWorkingPrecision},
a/.(AnalyticContinuationReplacements/.If[at>=0,{\[Theta]p->1,\[Theta]m->0},{\[Theta]p->0,\[Theta]m->1}])/.Logx->Log[x]/.x->at//SetPrecision[#,FEWorkingPrecision]&//Expand
];
SEval[a_SeriesData,at_]:=Block[{$MinPrecision=FEWorkingPrecision},
If[FEC[UsePade]===True,GetPade[a],Normal[a]]/.(AnalyticContinuationReplacements/.If[at>=0,{\[Theta]p->1,\[Theta]m->0},{\[Theta]p->0,\[Theta]m->1}])/.Logx->Log[x]/.x->at//SetPrecision[#,FEWorkingPrecision]&//Expand
];
SEval[0,at_]:=0;
SEval[a_/;NumericQ[a],at_]:=a;

(* Derivatives, avoiding Log[x] terms, which slow down the calculations. *)
SD[a_,b_]:=Block[{CurrMaxLogPower=MaxLogxPower[a],Tmp},
Sum[
Tmp=LogxCoeff[a,logxord];
D[Tmp,b]Logx^logxord+(D[Log[x]^logxord,b]/.Log[x]->Logx)Tmp
,{logxord,0,CurrMaxLogPower}]//SExpand
];
SD[a_,b__]:=SD[SD[a,{b}//First],Sequence@@Delete[{b},1]];
SD[a_]:=a;

(* Main integration function. *)
SetAttributes[DiffExpIntegrate1,Listable];
IntReps={};
DiffExpIntegrate[a__]:=Block[{LogOrd},
(* If maximum power of Logx has increased, update the replacement relations. *)
LogOrd=Append[GetCases[{a},Logx^(k_:1)|Log[x]^(k_:1):>k],1]//Max;
If[LogOrd>IMaxLogOrder,
PrintDebug["Encountered ",Log[x]^LogOrd,". Updating IntReps."][2];
UpdateIntReps[LogOrd];
];
DiffExpIntegrate1[a]
];
DiffExpIntegrate1[a_]:=DiffExpIntegrate1[a,x];
DiffExpIntegrate1[exp0_SeriesData,var_]:=Block[
{exp=(Expand@Normal@exp0)/.Logx->Log[x],Out,MaxPow,Const},
Out=exp/.var->b/.IntReps;
Const=(Out/.a->0);
MaxPow=Floor[(exp0[[5]]/exp0[[6]])];
SeriesAlways[Out-Const+b Const/.a->1/.b->var/.Log[x]->Logx,{x,0,MaxPow}]//SExpand
]
DiffExpIntegrate1[exp0_/;NumericQ[exp0],var_]:=SeriesAlways[var exp0,{x,0,ExpansionOrderVal}];
DiffExpIntegrate1[exp0_,var_]:=ReportError["DiffExpIntegrate called with unsupported arguments. ",exp0," ",var];
UpdateIntReps[MaxOrd_]:=Block[{},
IMaxLogOrder=MaxOrd;

IntReps=Join[
Table[Log[x]^n->a Integrate[Log[x]^n,x]/.x->b,{n,IMaxLogOrder}],
Table[Log[x]^n x->a Integrate[Log[x]^n x,x]/.x->b,{n,IMaxLogOrder}],
Table[Log[x]^n x^m_/;m!=-1->a Integrate[Log[x]^n x^m,x]/.x->b,{n,IMaxLogOrder}],
Table[Log[x]^n/x->a Integrate[Log[x]^n x^-1,x]/.x->b,{n,IMaxLogOrder}],
{x^m_/;m!=-1->a Integrate[x^m,x]/.x->b},
{x->a Integrate[x,x]/.x->b},
{1/x->a Integrate[1/x,x]/.x->b}
]//Reverse//Expand;
];

ToPiecewise[SavedData2_,Pade:_?BooleanQ:False,Ord_Integer:Null]:=Module[{SavedData,Res,Uncompressed},
If[MatchQ[SavedData2,{{a_Association,_},{__}}]||MatchQ[SavedData2,{{a_Association,_,_},{__}}],
SavedData=SavedData2[[2]],
SavedData=SavedData2
];

If[!(MatchQ[SavedData[[0]]===List]&&Quiet[Dimensions[SavedData][[2]]===5]),
ReportError["Could not interpret the argument. Maybe TransportTo[...] was not called with the option save_ set to True?"];
];

Counter=1;
If[!$FrontEnd===Null,
PrintTemporary["Processing ",Dynamic[Counter]];
];

If[FEC["SaveExpansionsCompress"]===True,
Uncompressed=SavedData[[1,5]]//Uncompress;
,
Uncompressed=SavedData[[1,5]];
];

Table[
Res=Piecewise@Table[
Counter={ind,intind,epsord};
If[FEC["SaveExpansionsCompress"]===True,
Uncompressed=SavedData[[ind,5]]//Uncompress;
,
Uncompressed=SavedData[[ind,5]];
];
{
(If[Pade===True,
(Project\[Theta]s[#,GetPade]&@#)/.Logx->Log[x]/.\[Theta]p->HeavisideTheta[x]/.\[Theta]m->HeavisideTheta[-x]/.(SavedData[[ind,2]]),
(Normal@#)/.Logx->Log[x]/.\[Theta]p->HeavisideTheta[x]/.\[Theta]m->HeavisideTheta[-x]/.(SavedData[[ind,2]])
]&@(Uncompressed[[intind,epsord]]+If[Ord===Null,0,O[x]^Ord]))
,
x>=SavedData[[ind,3,1]]&&x<=SavedData[[ind,3,2]]
}
,{ind,Length@SavedData}
];
Evaluate[Res/.x->#]&
,
{intind,Uncompressed//Dimensions//First},
{epsord,Uncompressed//Dimensions//Last}]
]

LoadConfiguration[a__]:=(
DiffExpConfiguration=DefaultConfiguration;
#[[1]][]&/@DiffExpExtensions;
UpdateConfiguration[a]
);
UpdateConfiguration[a__Rule]:=UpdateConfiguration[{a}];
UpdateConfiguration[l_List]:=UpdateConfiguration[l//Association];
UpdateConfiguration[assoc_Association]:=Module[{PSFL,DeltaPrescriptionsAdjusted},
DiffExpConfiguration=Merge[{DiffExpConfiguration,assoc},Last];

If[KeyExistsQ[assoc,LogFile],
If[ValueQ[LogStream],
Close[LogStream];
];
LogStream=OpenAppend[assoc[LogFile]];
AppendTo[$Output,LogStream];
AppendTo[$Messages,LogStream];
];
If[KeyExistsQ[FEC,"CrosscheckLevel"],
CurrCrosscheckFlags=Select[CrosscheckFlags//Normal,#[[2]]<=FEC["CrosscheckLevel"]&][[All,1]];
];
If[KeyExistsQ[FEC,"CrosscheckFlags"],
CurrCrosscheckFlags=Union[CurrCrosscheckFlags,FEC["CrosscheckFlags"]];
];
If[KeyExistsQ[assoc,WorkingPrecision]||KeyExistsQ[assoc,ChopPrecision],
If[FEC[ChopPrecision]>=FEC[WorkingPrecision],
ReportError["The value of ChopPrecision should be smaller than the value of WorkingPrecision."];
];
];
DiffExpConfiguration["LinearSolveChopPrecision"]=FEC[ChopPrecision];

If[KeyExistsQ[assoc,"LinearSolveChopPrecision"],
DiffExpConfiguration["LinearSolveChopPrecision"]=assoc["LinearSolveChopPrecision"];
];
If[KeyExistsQ[assoc,LineParameter]&&KeyExistsQ[FEC,Variables],
If[MemberQ[FEC[Variables],assoc[LineParameter]],
ReportError["The symbol for the line parameter can't be equal to one of the kinematic variables or masses."];
];
];
If[KeyExistsQ[assoc,LineParameter],
LineParameterVal=assoc[LineParameter];
x=assoc[LineParameter];
];
If[KeyExistsQ[assoc,DeltaPrescriptions],
DeltaPrescriptionsAdjusted=If[#[[0]]===List,#,
{#/.Global`\[Delta]->0,Coefficient[#,Global`\[Delta]]/I}
]&/@assoc[DeltaPrescriptions];
DiffExpConfiguration[DeltaPrescriptions]=DeltaPrescriptionsAdjusted;

(* We separately keep track of the delta prescriptions added by the user in another variable, since they might not contain the ones added from square roots. *)
UserDeltaPrescriptions=DeltaPrescriptionsAdjusted;
];

If[KeyExistsQ[assoc,"EstimateError"],
If[assoc["EstimateError"]==="False",
DiffExpConfiguration["EstimateError"]=False;
,
If[!MemberQ[{"Precise","Fast"},assoc["EstimateError"]],
DiffExpConfiguration["EstimateError"]=False;
];
];
];

If[KeyExistsQ[assoc,ExpansionOrderVal],
ExpansionOrderVal=DiffExpConfiguration[ExpansionOrderVal];
];

If[KeyExistsQ[assoc,DeltaPrescriptions],
PSFL=FactorList/@FEC[DeltaPrescriptions][[All,1]];
If[DependsQ[Length[#]>2&/@PSFL,True],
ReportError["Physical singularities should be irreducible polynomials!"];
];
];

If[KeyExistsQ[assoc,MatrixDirectory]||(KeyExistsQ[FEC,MatrixDirectory]&&KeyExistsQ[assoc,EpsilonOrder]),
If[(!KeyExistsQ[assoc,Variables])&&KeyExistsQ[assoc,MatrixDirectory],DiffExpConfiguration[Variables]={};];

LoadMatrices[MatrixDirectoryVal];
,
If[!KeyExistsQ[FEC,MatrixDirectory],
PrintWarning["No differential equations are loaded!"];
];
];

IntegrationSequence={};
DEqnMatricesFactored=Association[{}];
DEqnMatricesExpanded=Association[{}];
AlphabetLogRulesFactored=Association[{}];
AlphabetLogRulesExpanded=Association[{}];

AnalyticContinuationReplacementsAssociation=Association[{}];

UpdateIntReps[IMaxLogOrderDefault];

#[[2]][assoc]&/@DiffExpExtensions;

PrintInfo["Configuration updated."][1];

CurrentConfiguration[]
];

(* Loads files in the location of MatrixDirectory. *)
LoadMatrices[Folder_]:=Module[{TmpFiles,CurrFileName,CurrMatrix,DimTest,MatrixHeads,MHLeft,PSFL,NewSquareRootSingularities,Tmp,SqrtFlips,VarsPartialDerivatives,ExtraVars,AlphabetLogs,FilePattern,ExtraVarsEncountered},
PrintInfo["Loading matrices."][1];

VarsPartialDerivatives=FEC[Variables];
If[FEC[Variables]==={},
TmpFiles=FileNames[FileNameJoin[{FEC[MatrixDirectory],"d*_*.m"}]];

If[Length[TmpFiles]===0,
ReportError["No partial derivative matrices found in the given directory. The matrices should be labeled as: \"dscale_epsorder.m\"."];
];

FilePattern=Longest[pre__]~~$PathnameSeparator~~"d"~~Shortest[a___]~~"_"~~Shortest[b__]~~".m"/;NumericQ[ToExpression[b]];
PrintInfo["Found files: ",Flatten[StringCases[#,FilePattern:>"d"<>a<>"_"<>b<>".m"]&@TmpFiles]][1];
Tmp=Flatten[StringCases[#,FilePattern:>{a,b}],1]&/@TmpFiles;
Tmp=DeleteCases[Tmp,{}];
Tmp=ToExpression/@(Tmp[[All,1]]//DeleteDuplicates);
Tmp=DeleteCases[Tmp,Null];
VarsPartialDerivatives=Tmp;

If[MemberQ[Tmp,LineParameterVal],
ReportError["Some of the kinematic invariants or masses are named the same as the line parameter. Please change the symbol of the line parameter using the configuration option \"LineParameter\"."];
];
];

(* Handling of special canonical matrix file. *)
If[FileExistsQ[FileNameJoin[{FEC[MatrixDirectory],"d_1.m"}]],
ExpansionMatricesCanonical1=Import[FileNameJoin[{FEC[MatrixDirectory],"d_1.m"}]]//Expand;

(* Checking consistency of d_1.m *)
If[!(And@@Flatten[MapAt[
(And@@(MatchQ[#,(a_:1)Log[b_]/;NumericQ[a]]&/@DeleteCases[SplitSum[#],0]))&
,ExpansionMatricesCanonical1,{All,All}]])===True,
ReportError["The matrix d_1.m is not of the right form. It should be given as a combination of logarithms with numeric prefactors."];
];

AlphabetLogs=GetCases[ExpansionMatricesCanonical1,Log[a_]];

ExtraVars=AlphabetLogs/.Log[a_]:>a//Variables;
VarsPartialDerivatives=Union[VarsPartialDerivatives,ExtraVars];

AlphabetLogRules=Table[Log[Subscript[l, ind]]->AlphabetLogs[[ind]],{ind,Length[AlphabetLogs]}];

ExpansionMatricesCanonical1=ExpansionMatricesCanonical1/.(Reverse/@AlphabetLogRules);

PrintInfo["Loaded canonical matrix."][1];

,

ExpansionMatricesCanonical1="ZeroM";
AlphabetLogs={};
AlphabetLogRules={};

];

PrintInfo["Kinematic invariants and masses: ",VarsPartialDerivatives][1];
DiffExpConfiguration[Variables]=VarsPartialDerivatives;

ExpansionMatrices=Table[
CurrFileName=FileNameJoin[{MatrixDirectoryVal,"d"<>ToString[var]<>"_"<>ToString[ord]<>".m"}];

If[FileExistsQ[CurrFileName],
(* Matrix exists. *)
CurrMatrix=Import[CurrFileName];

If[!(ExtraVarsEncountered=Complement[Variables[CurrMatrix],ExternalScalesVal])==={},
ReportError["The file ","d"<>ToString[var]<>"_"<>ToString[ord]<>".m"," contains the variables: ",ExtraVarsEncountered,", but no partial derivative are given for these."];
];

{var,ord}->CurrMatrix
,
(* Matrix does not exist, assuming it is zero. *)
If[MemberQ[VarsPartialDerivatives,var]&&AlphabetLogs==={},
PrintInfo["Assuming M[",var,"][",ord,"] is zero."][1];
];

{var,ord}->"ZeroM"]

,{var,ExternalScalesVal},{ord,Range[0,EpsilonOrderVal]}
]//Flatten[#,1]&//Association;

(* Sanity check on matrix dimensions *)
DimTest=(If[!#==="ZeroM",#//Dimensions,Null]&/@Join[Values[ExpansionMatrices],{ExpansionMatricesCanonical1}])//DeleteCases[#,Null]&;

If[!(DimTest//SameQ),
ReportError["Loaded matrices are of different dimensions: ",DimTest];
];

PrintInfo["Loaded system of size ",ToString[#[[1]]]<>" x "<>ToString[#[[2]]]&@First@DeleteCases[Dimensions/@Join[Values[ExpansionMatrices],{ExpansionMatricesCanonical1}],{}]][1];

ExpansionMatrices=ExpansionMatrices/."ZeroM"->CA[0,{DimTest[[1,1]],DimTest[[1,1]]}];
ExpansionMatricesCanonical1=ExpansionMatricesCanonical1/."ZeroM"->CA[0,{DimTest[[1,1]],DimTest[[1,1]]}];

NumIntegrals=DimTest[[1,1]];

MatrixHeads=GetCases[Join[ExpansionMatrices//Values,AlphabetLogs/.Log[a_]:>a]//Flatten,a_:>a[[0]]];
MHLeft=Complement[MatrixHeads,{Association,List,Complex,Integer,Plus,Power,Rational,Symbol,Times}];

If[Length[MHLeft]>0,
ReportError["The differential equation matrices contain functions for which DiffExp has not been designed. It is expected that the matrices contain only rational functions, and square roots of rational functions. The function heads that were found are: ",MHLeft];
];

If[Length[GetCases[Join[ExpansionMatrices//Values,AlphabetLogs/.Log[a_]:>a],Power[a_,b_]/;Denominator[b]>2]]>0,
ReportError["Differential equations contain higher order roots. This behaviour has not been implemented yet."];
];

(* Detecting square roots in the differential equations, and assigning I\[Delta]-prescriptions. *)
DEqnSquareRoots=DeleteCases[
GetCases[{ExpansionMatrices//Values,AlphabetLogRules},Power[a_,b_]/;Denominator[b]===2:>Expand[a]],
!DependsQ[#,Alternatives@@ExternalScalesVal]&
];
DEqnSquareRoots=DeleteDuplicates[DEqnSquareRoots,Expand[#1]===Expand[#2]||Expand[#1]===Expand[-#2]&];

PSFL=FactorList/@DEqnSquareRoots;
If[DependsQ[Length[#]>2&/@PSFL,True],
ReportError["Matrices contain square roots which are not irreducible!"];
];

NewSquareRootSingularities=SquareRootPrescriptionsAdded[];

If[Length[NewSquareRootSingularities]>0,
PrintInfo["Additional square roots encountered in the partial derivative matrices:"][1];
PrintInfo[NewSquareRootSingularities[[All,1]]//TableForm][1];
PrintInfo["Assigning these roots +i\[Delta]."][1];
];

DiffExpConfiguration[DeltaPrescriptions]=Union[FEC[DeltaPrescriptions],SquareRootPrescriptionsAdded[]];

(* Flipping square roots which have -I\[Delta] prescription. *)
SqrtFlips=Table[
If[\[Sigma][[2]]===1,
Sqrt[-\[Sigma][[1]]//Expand]->-I Sqrt[\[Sigma][[1]]],
Sqrt[\[Sigma][[1]]]->-I Sqrt[-\[Sigma][[1]]//Expand]
]
,
{\[Sigma],DiffExpConfiguration[DeltaPrescriptions]}
];

If[Length[DEqnSquareRoots]>0,
PrintDebug["Flipping roots in matrices according to i\[Delta]-prescriptions given: ",
Select[{Sqrt[#]->(Sqrt[#]/.SqrtFlips),Sqrt[#]-(Sqrt[#]/.SqrtFlips)===0}&/@DEqnSquareRoots,#[[2]]===False&][[All,1]]
][1];
];

ExpansionMatrices=Association[Normal[ExpansionMatrices]/.a_^b_/;Denominator[b]==2:>a^(b-1/2) (Sqrt[a//Expand]/.SqrtFlips)];
AlphabetLogRules=AlphabetLogRules/.a_^b_/;Denominator[b]==2:>a^(b-1/2) (Sqrt[a//Expand]/.SqrtFlips);

(* Loading all the factors which may yield singularities. This will be used in the function FindMatrixSingularities. *)
PrintInfo["Getting irreducible factors.."][1];

MatricesIrreducibleFactors=Replace[
Join[
(FactorList/@({ExpansionMatrices//Values//Flatten//GetCases[#,a_^b_/;IntegerQ[b]&&b<0:>a]&,AlphabetLogs/.Log[a_]:>Factor[a]}//Flatten))//Flatten,
Cases[{ExpansionMatrices,AlphabetLogs},a_^b_/;Denominator[b]==2:>a,Infinity]
]//DeleteDuplicates//DeleteCases[#,a_/;!DependsQ[a,Alternatives@@FEC[Variables]]]&
,a_^b_/;Denominator[b]==2:>a,1]//DeleteDuplicates[#,Expand[#1]===Expand[#2]||Expand[#1]===Expand[-#2]&]&;

];

(* Prepares replacement rules for analytic continuation along the given line segment. *)
PrepareAnalyticContinuation[Line_]:=Module[{Tmp,Tmp2,SignsNeeded,SignNeeded,CurrSignChoices,FindVanishingFactors,AllPrescriptions,VanishingFactors},
FindVanishingFactors[Factors_]:=(
Tmp={Normal[LeadingCoefficientSeries[#[[1]]]],#[[2]]}&/@(Factors/.Line//Expand//PChop);
Tmp2=Table[{iind,Tmp[[iind]]},{iind,Length[Tmp]}];
Tmp2=Select[Tmp2,DependsQ[#[[2,1]],x]&];
VanishingFactors=Tmp2[[All,2]];
);

(* Check whether the singularity coincides with an automatically added +I\[Delta] coming from a root in the differential equations. *)
CurrentSingularityWasAddedFromSquareRoot=False;
FindVanishingFactors[SquareRootPrescriptionsAdded[]];
If[Length[VanishingFactors]>0,
FindVanishingFactors[Complement[DeltaPrescriptionsVal,SquareRootPrescriptionsAdded[]]];
If[Length[VanishingFactors]===0,
CurrentSingularityWasAddedFromSquareRoot=True;
];
];

FindVanishingFactors[DeltaPrescriptionsVal];
If[Length[VanishingFactors]>0,
CurrentSingularityHasIDeltaPrescription=True;,CurrentSingularityHasIDeltaPrescription=False
];

SignsNeeded=(
{Exponent[#[[1]],x],#[[2]]/(Sign[#[[1]]]/.Sign[x]->1)}/.{
{k_,1}:>(k/.{1->1,a_->"?"}),
{k_,-1}:>(k/.{1->-1,a_->"?"})
}
)&/@VanishingFactors;
SignNeeded=DeleteDuplicates@SignsNeeded;

CurrSignChoices=Thread[List[DeltaPrescriptionsVal[[Tmp2[[All,1]]]][[All,1]],SignsNeeded]];

If[(DependsQ[SignNeeded,"?"])||Length[SignNeeded]>1,
If[!KeyExistsQ[AnalyticContinuationReplacementsAssociation,Line],
PrintInfo["Singularity => Sign[Im[x]]:"][2];
PrintInfo[Rule@@#&/@(Thread[List[DeltaPrescriptionsVal[[Tmp2[[All,1]]]][[All,1]]+ I "\[Delta]" DeltaPrescriptionsVal[[Tmp2[[All,1]]]][[All,2]],SignsNeeded]])][2];
];
AnalyticContinuationFailed=True;
SignNeeded={1};
];

AnalyticContinuationReplacements={};
If[
SignNeeded==={-1},
AnalyticContinuationReplacements={
Logx->(\[Theta]p+\[Theta]m)Logx-2\[Pi] I \[Theta]m,
x^b_/;Denominator[b]==2:>x^(b-1/2) (\[Theta]p-\[Theta]m) Sqrt[x],
x^b_/;Denominator[b]>2:>(\[Theta]p + Exp[-2\[Pi] I b] \[Theta]m )x^b 
};
];

If[!KeyExistsQ[AnalyticContinuationReplacementsAssociation,Line],
If[SignNeeded==={},
PrintDebug["Line not centered at a singularity."][1];
,
PrintDebug["Analytic continuation: x carries ",SignNeeded[[1]],"*i\[Delta]"][1];
PrintDebug["Using replacement rules: ",AnalyticContinuationReplacements][1];
];
];

AnalyticContinuationReplacementsAssociation[Line]=AnalyticContinuationReplacements;
];

(* Detects the integration sequence. *)
InitializeIntegrationSequence[line_]:=Module[{dDot,HomogeneousMask,EdgeL,CurrIndex,IntegrationDependencies,KeysToDelete},
PrintDebug["Analyzing integration sequence on current line."][1];
HomogeneousMask=MapAt[ZeroQ,DEqnMatricesFactored[line][0],{All,All}];
(* A graph describing which integrals couple together in the differential equations.  *)
EdgeL=Flatten[MapIndexed[(CurrIndex=#2[[1]];CurrIndex->#&/@#1)&,(Flatten[Position[#,False]])&/@HomogeneousMask]];
EdgeL=Join[EdgeL,Table[DirectedEdge[i,i],{i,NumIntegrals}]]//DeleteDuplicates;
IntegrationDependencies=(#->VertexOutComponent[Graph[EdgeL],{#}])&/@Range[NumIntegrals];
(* Integration sequence and coupled integrals *)
IntegrationSequence=SortBy[IntegrationDependencies,Length[#[[2]]]&][[All,1]];
IntegrationSequence=Association[#->Union[GetCases[
ConnectedComponents[EdgeL//Graph,#]
,_Integer],{#}]&/@IntegrationSequence];
KeysToDelete=(DeleteDuplicates@*Flatten)[Delete[#,-1]&/@(IntegrationSequence//Values)];
IntegrationSequence=KeyDrop[IntegrationSequence,KeysToDelete]//Values;

PrintDebug["Integration sequence is ",IntegrationSequence][1];
MaxCouplingOrder=(Length/@IntegrationSequence)//Max;
PrintDebug["Maximum coupling order is ",MaxCouplingOrder][1];
];

PrepareBoundaryConditions[bcs_List,line2_Association|line2_List]:=Module[{line,CoeffList={},Coeffs,CoeffSer,bcs1,OneSer=(1//N[#,FEWorkingPrecision]&),Mask,ispoint,LineRat},
PrintDebug["Preparing boundary conditions."][1];

If[line2[[0]]===List,line=line2//Association//KeySort,line=line2//KeySort];

If[Accuracy[line]<FEWorkingPrecision,
line=line//Normal//SetPrecision[#,2FEWorkingPrecision]&//Association;
PrintWarning["Accuracy of the line/point is lower than the working precision. The precision has been artificially increased."];
];

If[Length[bcs]!=NumIntegrals,
PrintWarning["The number of integrals does not match the size of the system of differential equations."];
];

PrepareAnalyticContinuation[line];

ispoint=IsPoint[line];

If[ispoint&&Count[PChop[(MatricesIrreducibleFactors/.line//Together)],0]>0,
PrintWarning["The boundary conditions are given as numerical values at a point, but the point lies on a singularity of the differential equations. This only works if the asymptotic limit is finite."];
];

Table[
Switch[{bcs[[bcind,0]],bcs[[bcind]]}
,{List,_},
PrintDebug["Integral ",bcind,": List. Assuming first entry ~ \!\(\*SuperscriptBox[\(\[Epsilon]\), \(0\)]\)."][1];
If[Length[bcs[[bcind]]]<EpsilonOrderVal+1,
ReportError["Too few coefficients given for boundary conditions up to order \[Epsilon]^",EpsilonOrderVal];
];
Coeffs=bcs[[bcind]][[Range[EpsilonOrderVal+1]]];
,{String,"?"},
PrintInfo["Integral ",bcind,": Ignoring boundary conditions."][1];
Coeffs=CA["?",EpsilonOrderVal+1];

,_,
PrintDebug["Integral ",bcind,": Assuming closed form expression."][1];
CoeffSer=SeriesAlways[bcs[[bcind]],{\[Epsilon],0,EpsilonOrderVal}]//SExpand;

(* Sanity check *)
If[(CoeffSer//SeriesMinPower)<0,ReportError["The boundary conditions should start at finite order."]];

Coeffs=Table[SeriesCoefficient[CoeffSer,{\[Epsilon],0,ord}],{ord,0,EpsilonOrderVal}];

(* We put everything below the leading eps coefficient to zero for all orders of x. *)
If[!ispoint,
If[!bcs[[bcind]]===0,
Do[
If[!ispoint,PrintInfo["Assuming that integral ",bcind," is exactly zero at epsilon order ",iind-1,"."][1];];
Coeffs[[iind]]=\!\(\*
TagBox[
StyleBox[
RowBox[{"SeriesData", "[", 
RowBox[{"x", ",", "0", ",", 
RowBox[{"List", "[", "]"}], ",", "0", ",", 
RowBox[{"ExpansionOrderVal", "+", "1"}], ",", "1"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)
,{iind,CoeffSer[[4]]}];
];
];
];

AppendTo[CoeffList,Coeffs];
,
{bcind,bcs//Length}
];

bcs1=If[!ispoint,
Table[
If[!(#[[ind]][[0]]===SeriesData),
(
LeadingCoefficientSeries[(#[[ind]]/.line)*OneSer,2]
)/.OneSer "?"+O[x]^(1/2)->"?",
#[[ind]]
]
,
{ind,Length[#]}
]
,
If[DependsQ[Normal[#],x],
ReportError["The boundary terms that are provided depend on the line parameter ",x,", but the line itself does not."];
];
OneSer*#/.line
]&/@CoeffList;

If[!ispoint,
Mask=MapAt[Switch[#[[0]],
SeriesData,
tmp=#;
tmp[[3]]=Table["(...)",{ind,#[[3]]//Length}];
tmp,
_,#]&,bcs1,{All,All}]//TableForm;

PrintInfo["Prepared boundary conditions in asymptotic limit, of the form:"][1];
PrintInfo[Mask][1];
];

{line,bcs1}/.Log[a_ x]/;NumericQ[a]:>Log[a]+Logx/.Log[x]->Logx
];

ClearMatrices[line_]:=Module[{},
If[!FEC["KeepMatrixExpansions"]===True,
KeyDropFrom[DEqnMatricesFactored,line];
KeyDropFrom[DEqnMatricesExpanded,line];
];
];

ClearMatrices[]:=Module[{},
If[!FEC["KeepMatrixExpansions"]===True,
DEqnMatricesFactored=Association[];
DEqnMatricesExpanded=Association[];
];
];

(* Below follow functions for factoring and expanding the partial derivative matrices along a line. *)
PrepareMatrices[line_Association]:=(
If[!KeyExistsQ[DEqnMatricesExpanded,line],
PrepareMatricesFactored[line];
PrepareMatricesExpanded[line];
];
);

(* Prepare matrices along line segment, by reusing previously factored matrices. *)
PrepareMatricesFrom1[lineorig_Association,linenew_Association]:=Module[{ParRelns},

If[(!KeyExistsQ[DEqnMatricesFactored,linenew])&&(!KeyExistsQ[DEqnMatricesExpanded,linenew]),
PrintInfo["Preparing differential equations along current line segment."][2];
];

ParRelns=RelateLines[lineorig,linenew];

If[!KeyExistsQ[DEqnMatricesFactored,lineorig],
PrintDebug["Warning!: PrepareMatricesFrom is asked to re-use the results on ",lineorig," but these entries do not exist in the Association."][1];
PrepareMatricesFactored[linenew];
,

If[!KeyExistsQ[DEqnMatricesFactored,linenew],
DEqnMatricesFactored[linenew]=Association[
Table[
epsord->(PChop[If[FEC[UseMobius]===True,Identity,FactorOrTogether[lineorig,linenew]][(DEqnMatricesFactored[lineorig][epsord]/.x->ParRelns)D[ParRelns,x]]])
,{epsord,0,EpsilonOrderVal}]
];

If[!AlphabetLogRules==={},
AlphabetLogRulesFactored[linenew]=MapAt[(#/.Log[a_]:>Log[a/.linenew//FactorOrTogether[linenew]//PChop])&,AlphabetLogRules,{All,2}];
];

];
];
];

PrepareMatricesFrom[lineorig_Association,linenew_Association]:=(
PrepareMatricesFrom1[lineorig,linenew];
PrintInfo["Expanding partial derivative matrices."][2];
PrepareMatricesExpanded[linenew];
);

ExactLineQ[line_Association]:=And@@(ExactNumberQ/@Flatten[({
Numerator[#]/.x->0,
Coefficient[Numerator[#],x],
Denominator[#]/.x->0,
Coefficient[Denominator[#],x]}&/@(Together/@Values[line]))]);
FactorOrTogether[line_Association]:=If[ExactLineQ[line],Factor,Together];
FactorOrTogether[line1_Association,line2_Association]:=If[ExactLineQ[line1]&&ExactLineQ[line2],Factor,Together];

PrepareMatricesFactored[line_Association]:=(
If[!KeyExistsQ[DEqnMatricesFactored,line],
DEqnMatricesFactored[line]=Association[
Table[
epsord->(PChop[FactorOrTogether[line][Sum[(ExpansionMatrices[{v,epsord}]/.line)D[line[v],x],{v,ExternalScalesVal}]]])
,{epsord,0,EpsilonOrderVal}]
];

If[!AlphabetLogRules==={},
AlphabetLogRulesFactored[line]=MapAt[(#/.Log[a_]:>Log[a/.line//FactorOrTogether[line]//PChop])&,AlphabetLogRules,{All,2}];
];

];
);

PrepareMatricesExpanded[line_Association]:=(
If[!KeyExistsQ[DEqnMatricesExpanded,line],

DEqnMatricesExpanded[line]=Series[#//N[#,FEWorkingPrecision]&,{x,0,ExpansionOrderVal},Assumptions->x>0]&/@DEqnMatricesFactored[line];

If[!AlphabetLogRules==={},
AlphabetLogRulesExpanded[line]=MapAt[D[Series[
#//N[#,FEWorkingPrecision]&,{x,0,ExpansionOrderVal},Assumptions->x>0
],x]
&,AlphabetLogRulesFactored[line],{All,2}];

DEqnMatricesExpanded[line][1]=DEqnMatricesExpanded[line][1]+(ExpansionMatricesCanonical1/.AlphabetLogRulesExpanded[line])//SExpand;
];

];
);

NullSpaceTryAgainOnFail[ex_,r___]:=Module[{Res,ValidateTerm},
Res=NullSpace[ex,r];

If[Quiet[Length[Cases[Res,SeriesData[x,_,List[],k_,k_,_]/;k<0,Infinity]]>0],
PrintWarning["Encountered a problem while determining the nullspace of a matrix. Try setting the option \"HomogeneousSolve\" -> \"DontExpand\" "];

Global`DebugData={ex,r};
Abort[];

(*Res=(ex//Normal//NullSpace[#,r]&)+O[x]^ExpansionOrderVal;
PrintDebug["Validating solution.."][1];
Do[
PrintDebug["Checking vector.."][1];
ValidateTerm=(ex.Res[[ii]]//SExpand)//Normal//PChop//Flatten//DeleteDuplicates;

If[!ValidateTerm==={0},
Global`DebugData={ex,{r},Res,ValidateTerm};
ReportError["Could not obtain nullspace of a matrix. Aborting."];
];
,{ii,Length@Res}];*)
];

Res
]

(* Derives an n-th order differential equation for a single integral. *)
CombineDifferentialEquationsHomogeneous[Amat_,topind_:1]:=Module[{Amats,n=Amat//Length,Solns,MtildeMat},
PrintDebug["Getting higher order derivatives.."][2];

If[FEC["HomogeneousSolve"]==="Expand",
Amats=PChop@NestList[SExpand[(SD[#,x]+MatrixMultiplySExpand[#,Amat])]&,IdentityMatrix[n],n];
Solns=Amats[[All,topind]]//Transpose//NullSpaceTryAgainOnFail[#,Method->"DivisionFreeRowReduction",Tolerance->10^-LinearSolveChopPrecisionVal]&;

,

Amats=PChop@NestList[Together[(D[#,x]+# . Amat)]&,IdentityMatrix[n],n];
Solns=DiffExpSeries[Amats[[All,topind]]//Transpose//NullSpace[#]&//Together];
];

If[Length[Solns]>1,
Global`DebugData={Amats[[All,topind]]};
ReportError["Found multiple solutions while combining the differential equations. This may happen when the integrals become linearly dependent on the given line. Use the option IntegrationStrategy -> \"VariationOfParameters\" (note: this may run slower), or choose a different line."]
];

If[FEC["HomogeneousSolve"]==="Expand",
MtildeMat=PChop@DiffExpSeries[Amats[[All,topind]][[Range[n],Range[n]]]];
,
MtildeMat=Amats[[All,topind]][[Range[n],Range[n]]];
];

{Solns[[1]]/(Solns[[1]]//Last),MtildeMat}

];

(* Solution from the Frobenius ansatz. *)
Frobenius1[DEqn_]:=Module[{DEqnSer,n=Length[DEqn],IndicialEquation,rMax,Ansatz,c,Eqns,cUnknowns,cSols,r,tmp,tmp2,Maxc,IndicialDen,LeadingPowers},
LeadingPowers=(#[[4]]/#[[6]]&@LeadingCoefficientSeries[#,2])&/@DEqn;
LeadingPowers=LeadingPowers-Last[LeadingPowers];

Do[
(* Check that equation is Fuchsian *)
If[
LeadingPowers[[ind]]<ind-Length[LeadingPowers],
ReportError["Obtained a higher order differential equation that is not in Fuchsian form."];
];
,{ind,Length@LeadingPowers}
];

PrintDebug["Frobenius method: Series expanding.."][3];
DEqnSer=DiffExpSeries[DEqn];

IndicialEquation=Sum[LeadingCoefficientSeries[DEqnSer[[ind]]]( D[x^r,Sequence@@ConstantArray[x,ind-1]]x^-r),{ind,n}]//Normal//Rationalize[#,10^-ChopPrecisionVal]&;
PrintDebug["Indicial equation: ",IndicialEquation/.r->"r"][3];
rMax=Max[IndicialEquation==0//Solve[#,r]&//Part[#,All,1,2]&];
PrintDebug["Considering largest root: r = ",rMax][3];

If[Denominator[rMax]>2&&!(IgnoreIndicialCheck===True),
ReportError["The root of the indicial equation is of degree greater than two: ",rMax,". This case is not implemented in DiffExp."];
];

IndicialDen=Denominator[rMax];
cUnknowns=Table[Subscript[c, iind],{iind,IndicialDen ExpansionOrderVal}];
Ansatz=x^rMax Sum[Subscript[c, iind] x^iind/.Subscript[c, 0]->1,{iind,0,IndicialDen ExpansionOrderVal}]+O[x]^(IndicialDen ExpansionOrderVal);
Eqns=PChop[#==0&/@Sum[DEqnSer[[ind]]( D[Ansatz,Sequence@@ConstantArray[x,ind-1]]),{ind,n}][[3]]];

Check[
cSols=N[Thread[cUnknowns->LinearSolve[Sequence@@{#[[2]],-#[[1]]}&@CoefficientArrays[DeleteCases[Eqns,True],cUnknowns],ZeroTest->(N[LSPChop@Expand@Normal[#1],LinearSolveChopPrecisionVal]==0&)]],FEWorkingPrecision];
,
Global`DebugData={DEqn,DEqnSer,IndicialEquation,rMax,Ansatz,cUnknowns,Eqns,tmp,cSols};

If[DependsQ[cSols,LinearSolve],
ReportError["Something went wrong while applying the Frobenius method."];
,
PrintWarning["Encountered possible instability during evaluation of the Frobenius method. Cross-checking the result."];
tmp2=Ansatz/.(PChop[cSols]);
tmp2=Normal[SExpand@Sum[DEqnSer[[ord]]D[tmp2,Sequence@@ConstantArray[x,ord-1]],{ord,Length[DEqnSer]}]];
If[tmp2===0,
PrintInfo["Solution is valid. Continuing."][1];
,
ReportError["Result is incorrect. Aborting."];
];
];
];
PrintDebug["Frobenius solution found."][3];

Maxc=Max[Cases[Eqns,Subscript[c, i_]:>i,Infinity]];
Series[Ansatz,{x,0,Floor[Maxc+rMax]}]/.(PChop[cSols])
];

(* All Frobenius solutions. *)
FrobeniusSolutions[DEqn_]:=Module[{DEqnOrder=Length[DEqn]-1,Solns,DEqnReduced,DEqnSer,DEqnZeros,Checks,nTrail},
DEqnSer=DiffExpSeries[DEqn,ExpansionOrderVal];

DEqnZeros=If[Normal[#]===0,0,1]&/@DEqnSer;

Solns={Frobenius1[DEqnSer]};

If[DEqnOrder>1,
DEqnReduced=Table[
SExpand[Sum[
Binomial[iind-1,kind-1]SMultiply[
DEqnSer[[iind]],
SD[Solns[[1]],Sequence@@CA[x,iind-kind]]
],{iind,kind,DEqnOrder+1}]],{kind,DEqnOrder+1}];

(* Cross-check *)
If[MemberQ[CurrCrosscheckFlags,"FrobeniusSolutions"]===True,
If[!Normal[(CPChop@DEqnReduced[[1]])]===0,
PrintDebug[DEqnReduced[[1]]+O[x]^ExpansionOrderVal//SN][3];
ReportError["Something went wrong while deriving a lower order differential equation from a multiplicative ansatz. Possibly the value of ChopPrecision is set too low."];
];
];

DEqnReduced=Delete[DEqnReduced,1];
Solns=Join[
Solns,
SMultiply[Solns[[1]],#]&/@DiffExpIntegrate[FrobeniusSolutions[DEqnReduced]]
];
];

If[MemberQ[CurrCrosscheckFlags,"FrobeniusSolutions"]===True,
PrintDebug["Running cross-checks on Frobenius solutions.."][1];
Checks=(CPChop@*SExpand)[Sum[
SMultiply[DEqnSer[[iind]],SD[#,Sequence@@CA[x,iind-1]]]
,{iind,DEqnOrder+1}]]&/@Solns;
PrintDebug["Cross-checks: ",Checks//SN][3];
If[!SameQ[Append[Normal[Checks],0]],
ReportError["Error while validating the Frobenius solutions. Aborting.."];
];
];

Solns
];

(* Relates line parameters of different segments. *)
RelateLines[a2_Association,b2_Association,noerror_:False]:=Module[{a=KeySort[a2],b=KeySort[b2],Sol,Sols,CanSolveFrom,SFKey,SugSol},

(* We find one component of a that contains x, and use that to solve the equation. We check the solution up to the ChopPrecision with the other entries. *)
CanSolveFrom=Flatten[Position[DependsQ[PChop@Expand@#,x]&/@a,True]];
If[Length[CanSolveFrom]===0,
Global`DebugData={a,b};
ReportError["Argument does not depend on the line parameter!"];
];

SFKey=CanSolveFrom[[1,1]];

Sol=Quiet[Solve[(a[SFKey]/.x->y)-b[SFKey]==0,y]];

If[Length[Sol]>1,
ReportError["Multiple solutions encountered while relating lines: ",a//Normal//N//Association," and ",b//Normal//N//Association,". This is likely because you chose a non-linear line segment. Such line segments are not currently supported."];
];

If[!(Length[Sol]===1),
Global`DebugData={a,b};
If[!noerror,ReportError["Could not relate lines."];];
False,
(*Crosscheck*)
SugSol=Sol[[1,1,2]]//Together//PChop;

Quiet[
If[!(SameQ@@Append[Values[(PChop@Together@N[#,FEC[WorkingPrecision]])&/@((a/.x->SugSol)-b)],0]),
PrintDebug["Could not relate lines:"][1];
PrintDebug[Values[(a/.x->SugSol)-b]//Factor//N][1];
Global`DebugData={a,b};

If[!noerror,ReportError["Could not relate lines."];];
False,
SugSol
]
]
]
]
RelateLinesPoint[a_Association,b_Association,pointb_]:=RelateLines[a,b]/.x->pointb;

(* Derives Subscript[X, sing] *)
FindMatrixSingularities[line_,getcomplex_:False,{fixat_,to_}]:=Module[{AllSingularTerms,RatPoles,Sqrts,SPos1,SPos1N,SPos,SPosProjections,MySing,MySingN,NumPoles,Tmp,Tmp2,Tmp3,Tmp4},
PrintInfo["Determining positions of singularities and branch-cuts."][1];

AllSingularTerms=Flatten[FactorList/@Factor[Union[MatricesIrreducibleFactors/.line,Denominator@Together@Values@line]]]//DeleteDuplicates//DeleteCases[#,a_/;!DependsQ[a,x]]&//DeleteDuplicates[#,Expand[#1]===Expand[#2]||Expand[#1]===Expand[-#2]&]&;
SPos1=Quiet[Solve[#==0,x]&/@AllSingularTerms];
SPos1=Join[(SPos1//Flatten)[[All,2]]//DeleteDuplicatesBy[#,N[#,ChopPrecisionVal]&]&,{-\[Infinity],\[Infinity]}]//Sort[#,Re[N[#1,ChopPrecisionVal]]<Re[N[#2,ChopPrecisionVal]]&]&;
SPos1N=N[SPos1,FEWorkingPrecision];

(* Project complex singularities onto the real line. *)
SPosProjections=(
MySing=#[[1]];MySingN=#[[2]];

LI=Select[SPos1N,Re[MySingN]-Im[MySingN]<Re[#]<Re[MySingN]&];
RI=Select[SPos1N,Re[MySingN]<Re[#]<Re[MySingN]+Im[MySingN]&];

{
If[LI==={},Re[MySing]-Im[MySing],Null],
Re[MySing],
If[RI==={},Re[MySing]+Im[MySing],Null]
}

)&/@Transpose[{SPos1,SPos1N}];

Quiet[
SPos=Sort[DeleteDuplicatesBy[DeleteCases[Flatten[SPosProjections],Null],N[#,ChopPrecisionVal]&],N[#1,FEWorkingPrecision]<N[#2,FEWorkingPrecision]&];
];

If[getcomplex===True,
{SPos,SPos1}
,
SPos
]
];

(* Normalizes terms in numerator and denominator for printing. *)
PrintMobiusNormalized[a_]:=Module[{Tmp=a//Together,mt,md,m},
mt=Max[Abs/@{Coefficient[Tmp//Numerator,x],(Tmp//Numerator)/.x->0}];
md=Max[Abs/@{Coefficient[Tmp//Denominator,x],(Tmp//Denominator)/.x->0}];
m=Max[mt,md];
Expand[Numerator[Tmp]/m]/Expand[Denominator[Tmp]/m]//N
];

(* Gives a large term which can be used to estimate the error. *)
GetLargestTerm[line_]:=Block[{},
(Flatten[Coefficient[DEqnMatricesExpanded[line]//Values,x,ExpansionOrderVal-ISafetyExpansionSubtract-(MaxCouplingOrder-1)]]//Abs//Max)x^(ExpansionOrderVal-ISafetyExpansionSubtract-(MaxCouplingOrder-1))
];

TransportTo[bcs2_List,line2_Association|line2_List,to2:_?NumericQ:1,SaveExpansions:_?BooleanQ:False]:=Module[{line=If[line2[[0]]===List,line2//Association//KeySort,line2//KeySort],LineRat,ToRat,to,Tmp,bcs,FixAt,MySingularities,MySingularitiesImaginary,MySingularitiesRelevant,SingularitySegments,PoleIntervals,CurrLine,CurrLineNoMobius=Null,CurrIntegrated,CurrIntervalCurrLine,CurrIntervalLine,Done=False,Tmp2,CurrEvalPoint,CurrEvalPointCurrLine,CurrEval,Currbcs,AllIntegrationData={},MyCenter,EvaluateCurrPoint,NextIsPole=False,SegmentCounter=1,TmpRelateLines,InterSec,CurrIntervalLinePos,CurrIntervalLineNeg,CurrEvalError,CurrIntegratedError,CurrbcsError,PrintError,CurrError,CurrErrorAcc=0,CurrErrorAccs=ConstantArray[0,{NumIntegrals,EpsilonOrderVal+1}],FixWithin,SegmentsToIntegrate,UpdateMatrixExpansionError,TimeStart,TimeStart0,LineReturn,FailedLine,ExpansionsIndeterminates={},bcsprev,CurrStatusBackup,BoundaryFixPoint,CurrEvalErrorEx,CurrEvalError1,CurrEvalError2,CurrEvalAtBoundaryFixPoint,CurrEvalEx
},

MultivaluedFail=False;

If[Or@@(!DependsQ[Keys@line,#]&/@ExternalScalesVal),
ReportError["The point/line in the second argument does not fix all kinematic invariants and masses!"];
];

ExpansionOrderVal=FEC[ExpansionOrder];
DigitsNeeded=FEAccuracyGoal+ISafetyDigits;
TimeStart0=AbsoluteTime[];

(* To deal with the output of SaveExpansions = True *)
If[MatchQ[bcs2,{{a_Association,__},_}],
bcs=bcs2[[1]];,
bcs=bcs2;
];

bcs[[1]]=bcs[[1]]//KeySort;

(* Increase precision of arguments. *)
If[Accuracy[line]<FEWorkingPrecision,
line=line//Normal//SetPrecision[#,2*FEWorkingPrecision]&//Association;
PrintWarning["Accuracy of the line/point is lower than the working precision. The precision has been artificially increased."];
];

If[IsPoint[line],
If[IsPoint[bcs[[1]]],
line=Merge[{bcs[[1]],line},Expand[#[[1]](1-x)+x #[[2]]]&];
,
Tmp=RelateLines[bcs[[1]],line,True];
If[Tmp===False,ReportError["Endpoint does not lie on same line as the boundary conditions."]];
line=bcs[[1]]/.x->x Tmp;
];
to=1;
,
to=to2;

If[Accuracy[to]<FEWorkingPrecision,
to=to//SetPrecision[#,2*FEWorkingPrecision]&;
PrintWarning["Accuracy of the endpoint is lower than the working precision. The precision has been artificially increased."];
];
];

ExpansionsIndeterminates=DeleteCases[bcs[[2]]//Variables,"?"|x|Logx];
If[Length[ExpansionsIndeterminates]>0&&FEC[UsePade]===True,
PrintInfo["The use of Pad\[EAcute] approximants is not possible when transporting boundary conditions with indeterminate coefficients. Pade approximants will be turned off."][1];
DiffExpConfiguration[UsePade]=False;
];

(* Check whether the line lies on a singularity of the differential equations. *)
If[Length[Tmp=Flatten[Position[Factor[MatricesIrreducibleFactors/.line],0]]]>0,
ReportError["The line lies on a singularity of the differential equations. The vanishing factors are: ",MatricesIrreducibleFactors[[Tmp]],"."];
];

(* Will abort if something is wrong with the boundary conditions. *)
{bcs,FixAt}=CheckBoundaryConditionsAndReparametrize[bcsprev=bcs,line];

If[Length[bcsprev]>2,
CurrErrorAcc=bcsprev[[3]]//Abs//Max;
CurrErrorAccs=bcsprev[[3]];
,
Quiet[
CurrErrorAccs=10^-(MapAt[Accuracy,bcsprev[[2]],{All,All}]//SetPrecision[#,FEWorkingPrecision]&);
CurrErrorAcc=CurrErrorAccs//Max;
];
];

If[!((CurrErrorAccs//Dimensions//Last)===EpsilonOrderVal+1),
CurrErrorAccs=PadRight[#,EpsilonOrderVal+1,10^-FEWorkingPrecision]&/@CurrErrorAccs;
];

PrintInfo["Transporting boundary conditions along ",line//Normal//N//Association," from x = ",FixAt//N," to x = ",to//N][1];

PrintInfo["Preparing differential equations along current line.."][1];
PrepareMatricesFactored[line];

InitializeIntegrationSequence[line];

{MySingularities,MySingularitiesImaginary}=FindMatrixSingularities[line,True,{FixAt,to}];

MySingularitiesRelevant=Select[MySingularities,FixAt<=#<=to||to<=#<=FixAt&];
If[FEC[UseMobius]===True,
SingularitySegments={
#,
GetLineRescaled[line,#,{MySingularities,MySingularitiesImaginary}],
GetLineRescaled[line,#,{MySingularities,MySingularitiesImaginary},True]
}&/@MySingularitiesRelevant;
,
SingularitySegments={#,GetLineRescaled[line,#,{MySingularities,MySingularitiesImaginary}]}&/@MySingularitiesRelevant;
];

PrintInfo["Possible singularities along line at positions ",DeleteCases[SingularitySegments[[All,1]],\[Infinity]|-\[Infinity]]//N,"."][1];

If[FEC[SegmentationStrategy]==="Dynamic",
PrintInfo["Determining intervals around possible singularities."][1];
];

PoleIntervals=Table[
If[FEC[SegmentationStrategy]==="Dynamic",
PrintInfo["Expanding differential equations around x = ",sline[[1]]//N,"."][1];

PrepareAnalyticContinuation[sline[[2]]];
PrepareMatricesFrom(*Mobius*)[line,sline[[2]](*,
If[Length[sline]===3,sline[[3]],Null]*)
];

Tmp={-#,#}&@GetMatricesPrecisionDistance[sline[[2]]];
];

If[FEC[SegmentationStrategy]==="Predivision",
Tmp={-RadiusOfConvergenceVal/FEC[DivisionOrder],RadiusOfConvergenceVal/FEC[DivisionOrder]};
];

Tmp={sline,RelateLinesPoint[line,sline[[2]],#]&/@Tmp};

PrintInfo["Expansion around x = ",sline[[1]]//N, " is valid within region x \[Element] [",Tmp[[2,1]]//N,", ",Tmp[[2,2]]//N,"]."][2];

Tmp
,
{sline,SingularitySegments}
];

(* Main loop. *)
If[DependsQ[#===0&/@(SingularitySegments//PChop),True],
PrintDebug["First expansion is at singularity."][1];
];













(* Duplicate of the code block below, without print statements and integrations. This counts the number of segments. *)
If[FEC[SegmentationStrategy]==="Predivision",
PrintInfo["Analyzing integration segments."][1];
PoleIntervals1=PoleIntervals;
MyCenter=FixAt;
CurrLine=GetLineRescaled[line,FixAt,{MySingularities,MySingularitiesImaginary}];

Done=False;
While[!Done,
PoleIntervals=Select[PoleIntervals,!(#[[1,1]]===MyCenter)&];

CurrIntervalCurrLine={-RadiusOfConvergenceVal/FEC[DivisionOrder],RadiusOfConvergenceVal/FEC[DivisionOrder]};
CurrIntervalLine=RelateLinesPoint[line,CurrLine,#]&/@CurrIntervalCurrLine;

If[IntervalContainsQ[CurrIntervalLine,to],
CurrEvalPoint=to;
CurrEvalPointCurrLine=RelateLinesPoint[CurrLine,line,CurrEvalPoint];

Done=True;

,
SegmentCounter+=1;

If[to>FixAt,
Tmp=Select[PoleIntervals,#[[1,1]]>MyCenter&];
,
Tmp=Select[PoleIntervals,#[[1,1]]<=MyCenter&];
];
Tmp2={#[[1]],IntervalOverlapQ[CurrIntervalLine,#[[2]]]}&/@Tmp;
Tmp2=Flatten[Position[Tmp2[[All,2]],True]];
NextIsPole=Length[Tmp2]>0;

If[NextIsPole,
Tmp=Tmp[[Tmp2[[1]]]];

If[to>FixAt,
FixWithin=IntervalIntersec[IntervalIntersec[{MyCenter,Tmp[[1,1]]},Tmp[[2]]],CurrIntervalLine];
CurrEvalPoint=(FixWithin[[1]]+FixWithin[[2]])/2;
,

FixWithin=IntervalIntersec[IntervalIntersec[{Tmp[[1,1]],MyCenter},Tmp[[2]]],CurrIntervalLine];
CurrEvalPoint=(FixWithin[[1]]+FixWithin[[2]])/2;
];

CurrEvalPointCurrLine=RelateLinesPoint[CurrLine,line,CurrEvalPoint];

MyCenter=Tmp[[1,1]];
CurrLine=Tmp[[1,2]];
If[FEC[UseMobius]===True,CurrLineNoMobius=Tmp[[1,3]]];
,

(* Finite point *)
If[to>FixAt,
CurrEvalPoint=CurrIntervalLine[[2]],
CurrEvalPoint=CurrIntervalLine[[1]]
];
CurrEvalPointCurrLine=RelateLinesPoint[CurrLine,line,CurrEvalPoint];

If[FEC[SegmentationStrategy]==="Dynamic",
MyCenter=CurrEvalPoint;
];

If[FEC[SegmentationStrategy]==="Predivision",
If[to>FixAt,
MyCenter=FindNextCenterPointL[CurrEvalPoint,MySingularities],
MyCenter=FindNextCenterPointR[CurrEvalPoint,MySingularities]
];
];

CurrLine=GetLineRescaled[line,MyCenter,{MySingularities,MySingularitiesImaginary}];
];
];

PoleIntervals=PoleIntervals1;
];




PrintInfo["Segments to integrate: ",SegmentsToIntegrate=SegmentCounter,"."][1];
];













SegmentCounter=1;
ExpansionOrders={ExpansionOrderVal};

If[FEC[SegmentationStrategy]==="Predivision",
DigitsNeeded=FEAccuracyGoal+Ceiling[Log10[SegmentsToIntegrate]]+ISafetyDigits;
];

UpdateMatrixExpansionError[]:=Block[{CurrErrorTerms,CurrErrorLeft,CurrErrorRight},
CurrErrorTerms=GetLargestTerm[CurrLine];

If[FixAtLineSegment===0,
CurrErrorLeft=0;,
CurrErrorLeft=CurrErrorTerms/.(AnalyticContinuationReplacements/.If[FixAtLineSegment>=0,{\[Theta]p->1,\[Theta]m->0},{\[Theta]p->0,\[Theta]m->1}])/.Logx->Log[x]/.x->FixAtLineSegment//Abs//N[#,FEWorkingPrecision]&//Max;
];
CurrErrorRight=CurrErrorTerms/.(AnalyticContinuationReplacements/.If[CurrEvalPointCurrLine>=0,{\[Theta]p->1,\[Theta]m->0},{\[Theta]p->0,\[Theta]m->1}])/.Logx->Log[x]/.x->CurrEvalPointCurrLine//Abs//N[#,FEWorkingPrecision]&//Max;
CurrError=Max[CurrErrorLeft,CurrErrorRight]
];

EvaluateCurrPoint[]:=Block[{ErrorSufficient,FixAtLineSegment,NumExpansions,DigitsHave,DeltaDigits,DEqnMatricesExpandedBackup,CurrErrorBackup,MyCounter},(

If[FEC[SegmentationStrategy]=="Predivision"&&KeyExistsQ[DiffExpConfiguration,AccuracyGoal]&&DiffExpConfiguration["AccuracyGoalValidate"]==="Before",
If[NumericQ[DiffExpConfiguration[AccuracyGoal]],
ErrorSufficient=False;
FixAtLineSegment=GetMatchingPoint[CurrLine,Currbcs[[1]]];
ExpansionOrderVal=Ceiling[Mean[ExpansionOrders]];

PrintInfo["Determining expansion order for given accuracy goal."][2];
NumExpansions=1;
While[!ErrorSufficient,
PrintInfo["Expanding differential equations at order: ",ExpansionOrderVal][2];
KeyDropFrom[DEqnMatricesExpanded,CurrLine];
PrepareMatricesExpanded[CurrLine];

UpdateMatrixExpansionError[];

DigitsHave=-Log10[CurrError];
DeltaDigits=DigitsNeeded-DigitsHave;

If[DeltaDigits<0,
If[NumExpansions==1&&-DeltaDigits>IDigitsSurplusDecreaseExpansionOrder,
MyCounter=1;
While[-DeltaDigits>IDigitsSurplusDecreaseExpansionOrder&&ExpansionOrderVal-IExpansionOrderDecrease>=IMinExpansionOrder,
If[MyCounter>1,
PrintInfo["Reducing expansion order..: ",ExpansionOrderVal][2];
];
DEqnMatricesExpandedBackup=DEqnMatricesExpanded[line];
CurrErrorBackup=CurrError;

ExpansionOrderVal-=IExpansionOrderDecrease;
DEqnMatricesExpanded[line]=#+O[x]^ExpansionOrderVal&/@DEqnMatricesExpanded[line];

UpdateMatrixExpansionError[];
DigitsHave=-Log10[CurrError];
DeltaDigits=DigitsNeeded-DigitsHave;

MyCounter++;
];

ExpansionOrderVal+=IExpansionOrderDecrease;
DEqnMatricesExpanded[line]=DEqnMatricesExpandedBackup;
CurrError=CurrErrorBackup;

PrintInfo["Error of matrix expansions: ",CurrError//N][2];
If[MyCounter==2,
PrintInfo["Precision reached at order: ",ExpansionOrderVal][2];
];

,

PrintInfo["Error of matrix expansions: ",CurrError//N][2];
PrintInfo["Precision reached at order: ",ExpansionOrderVal][2];

];
AppendTo[ExpansionOrders,ExpansionOrderVal];
If[Length[ExpansionOrders]>IExpansionOrdersAveraging,
ExpansionOrders=Delete[ExpansionOrders,1];
];
ErrorSufficient=True;
,
PrintInfo["Error of matrix expansions: ",CurrError//N][2];
ExpansionOrderVal+=IExpansionOrderIncrease;
NumExpansions++;
];
];
];
];

LastBoundaryConditions=Append[Currbcs,CurrErrorAccs];
LastIntegrateSystemCall=IntegrateSystem2[Currbcs,CurrLine,{"TransportToCall"}];
CurrIntegrated=IntegrateSystem[Currbcs,CurrLine,{"TransportToCall"}];

If[FEC["EstimateError"]==="Precise",
PrintInfo["Estimating error.."][2];
CurrIntegratedError=IntegrateSystem[CurrbcsError,CurrLine,{"TransportToCall","DecreaseOrderBy1"}];
];

If[SaveExpansions===True,
TmpRelateLines=x->RelateLines[CurrLine,line];
AppendTo[AllIntegrationData,{
CurrLine,(* Current line *)
TmpRelateLines, (* Change of line parameter from CurrLine to line *)
If[to>FixAt,Identity,Reverse]@{Limit[RelateLines[line,Currbcs[[1]]],x->0],CurrEvalPoint},(*  Expansions gives results on line between x and y *)
{Limit[RelateLines[CurrLine,Currbcs[[1]]],x->0],CurrEvalPointCurrLine},(*  Expansions gives results on CurrLine between x and y *)
If[FEC["SaveExpansionsCompress"]===True,
(ApplyAnalyticContinuation[CurrIntegrated]//Project\[Theta]s)//Compress (* And the expansion data itself *)
,
(ApplyAnalyticContinuation[CurrIntegrated]//Project\[Theta]s) (* And the expansion data itself *)
]
}];
];

(* If MultivaluedFail is True, then multivalued functions were encountered but no singularity was expected. We then abort the computation early. *)
If[!MultivaluedFail,

PrintInfo["Evaluating at x = ",CurrEvalPoint//N][1];
Global`DebugData=CurrIntegrated;
(* Either returns the Pade approximant, or the series with Normal applied *)
CurrEvalEx=SEval1[CurrIntegrated];
CurrEval=SEval2[CurrEvalEx,CurrEvalPointCurrLine];
If[!FEC["EstimateError"]===False,
Switch[FEC["EstimateError"],
"Fast",
(* Obtain the point at which the boundary conditions were fixed. *)
BoundaryFixPoint=GetMatchingPoint[CurrLine,Currbcs[[1]]];
(* We compute the error both at the position where the boundary conditions were fixed, and at the evaluation point of the current line segment.*)
CurrEvalErrorEx=SEval1[CurrIntegrated//DecreaseSeriesOrderBy[#,ICurrEvalErrorSeriesDecrease]&];
CurrEvalError1=SEval2[CurrEvalErrorEx,CurrEvalPointCurrLine];
(* We avoid the point 0, because there might be logarithms, and the error should be manifestly zero. *)
If[!BoundaryFixPoint===0,
CurrEvalError2=SEval2[CurrEvalErrorEx,BoundaryFixPoint];
CurrEvalAtBoundaryFixPoint=SEval2[CurrEvalEx,BoundaryFixPoint];
,
(* As a small hack, we set the same values as at the endpoint. *)
CurrEvalError2=CurrEvalError1;
CurrEvalAtBoundaryFixPoint=CurrEval;
];

,"Precise",CurrEvalError=SEval[CurrIntegratedError,CurrEvalPointCurrLine];
];
];

PrintInfo[
If[FEC[SegmentationStrategy]==="Predivision",
"Integrated segment "<>ToString[SegmentCounter-1]<>" out of "<>ToString[SegmentsToIntegrate]<>" in ",
"Integrated segment in "
],
AbsoluteTime[]-TimeStart//N,
" seconds."
][1];

,

(* Computation should be aborted and last integrated system should be returned *)
FailedLine=CurrLine;
CurrEval=CurrIntegrated;
CurrEvalError=Table[0,{ii,NumIntegrals},{jj,0,EpsilonOrderVal}];

(*PrintInfo["Quitting prematurely."][1];
DebugData=CurrEval;
Abort[];*)

];

)];

ComputeErrorsPerIndeterminate[aaa_,bbb_,ExpansionsIndeterminates_]:=Module[{TmpErrors},
TmpErrors=Table[LogxCoeffNS[aaa-bbb,logxord],{logxord,0,IMaxLogOrder}];
TmpErrors=Table[(

Flatten[
Append[
Table[
Coefficient[TmpErrors[[All,ii,jj]],var]
,
{var,ExpansionsIndeterminates}]
,
TmpErrors[[All,ii,jj]]/.(#->0&/@ExpansionsIndeterminates)
]
]

)//Abs//Max,{ii,(TmpErrors//Dimensions)[[2]]},{jj,(TmpErrors//Dimensions)[[3]]}]//N
];

PrintError[]:=Block[{TmpErrors,TmpErrors1,TmpErrors2},

If[!MultivaluedFail,

ExpansionsIndeterminates=DeleteCases[Currbcs[[2]]//Variables,"?"|x|Logx];

TmpErrors1=ComputeErrorsPerIndeterminate[CurrEvalError1,CurrEval,ExpansionsIndeterminates];
TmpErrors2=ComputeErrorsPerIndeterminate[CurrEvalError2,CurrEvalAtBoundaryFixPoint,ExpansionsIndeterminates];
TmpErrors=Table[Max[{TmpErrors1[[ii,jj]],TmpErrors2[[ii,jj]]}],{ii,First@Dimensions@TmpErrors1},{jj,Last@Dimensions@TmpErrors1}];

CurrError=Flatten[TmpErrors]//Abs//Max;

Switch[FEC["EstimateError"],
"Precise",CurrError,
"Fast",
CurrErrorAcc=CurrErrorAcc+CurrError;
CurrErrorAccs=CurrErrorAccs+TmpErrors;
];

Which[FEC["EstimateError"]=="Fast",
PrintInfo["Current segment error estimate: ",CurrError][1];
PrintInfo["Total error estimate: ",CurrErrorAcc][1];
,FEC["EstimateError"]=="Precise",
PrintInfo["Current error estimate: ",CurrError][1];
];

If[CurrError>1,
ReportError["The reported error is very large. This likely indicates a numerical instability."];
];

];

];

MyCenter=FixAt;
CurrLine=GetLineRescaled[line,FixAt,{MySingularities,MySingularitiesImaginary}];
If[FEC[UseMobius]===True,CurrLineNoMobius=GetLineRescaled[line,FixAt,{MySingularities,MySingularitiesImaginary},True]];
Currbcs=CurrbcsError=bcs;

Done=False;
While[!Done,
TimeStart=AbsoluteTime[];

CurrStatusBackup={Currbcs,CurrbcsError,bcs,CurrLine,MyCenter,FixAt,CurrErrorAcc,CurrErrorAccs};

PrintInfo["Integrating segment: ",PrintMobiusNormalized/@CurrLine,"."][1];
If[NextIsPole&&MemberQ[MySingularitiesImaginary,MyCenter],
PrintInfo["Current segment is centered at singularity."][1];
];

LastEvaluation=Currbcs;
LastSavedData=AllIntegrationData;
LastLine=CurrLine;

PoleIntervals=Select[PoleIntervals,!(#[[1,1]]===MyCenter)&];

AnalyticContinuationFailed=False;
PrepareAnalyticContinuation[CurrLine];
If[AnalyticContinuationFailed===True&&(SegmentCounter>1||to<FixAt),
If[SegmentCounter===1&&to<FixAt,
ReportError["Can only perform the expansions for x > 0 along the current line segment. Please integrate in the positive line direction."];
,
ReportError["Analytic continuation failed. Please separate out the singularities by transporting along a different line."];
];
];

If[FEC[SegmentationStrategy]==="Dynamic",
PrepareMatricesFrom[line,CurrLine];
CurrIntervalCurrLine={-#,#}&@GetMatricesPrecisionDistance[CurrLine];
];
If[FEC[SegmentationStrategy]==="Predivision",
PrepareMatricesFrom1[line,CurrLine];
CurrIntervalCurrLine={-RadiusOfConvergenceVal/FEC[DivisionOrder],RadiusOfConvergenceVal/FEC[DivisionOrder]};
];
CurrIntervalLine=RelateLinesPoint[line,CurrLine,#]&/@CurrIntervalCurrLine;
PrintInfo["Current line segment covers x \[Element] [",CurrIntervalLine[[1]]//N,", ",CurrIntervalLine[[2]]//N,"]."][2];
SegmentCounter+=1;

If[IntervalContainsQ[CurrIntervalLine,to],
CurrEvalPoint=to;
CurrEvalPointCurrLine=RelateLinesPoint[CurrLine,line,CurrEvalPoint];
EvaluateCurrPoint[];

Currbcs={line/.x->CurrEvalPoint,CurrEval};
If[!FEC["EstimateError"]===False,
CurrbcsError={line/.x->CurrEvalPoint,CurrEvalError};
PrintError[];
];

Done=True;

,

If[to>FixAt,
Tmp=Select[PoleIntervals,#[[1,1]]>MyCenter&];
,
Tmp=Select[PoleIntervals,#[[1,1]]<=MyCenter&];
];
Tmp2={#[[1]],IntervalOverlapQ[CurrIntervalLine,#[[2]]]}&/@Tmp;
Tmp2=Flatten[Position[Tmp2[[All,2]],True]];
NextIsPole=Length[Tmp2]>0;

If[NextIsPole,
Tmp=Tmp[[Tmp2[[1]]]];

If[to>FixAt,
(* (Current line center, pole center), (poleinterval) *)
FixWithin=IntervalIntersec[IntervalIntersec[{MyCenter,Tmp[[1,1]]},Tmp[[2]]],CurrIntervalLine];
CurrEvalPoint=(FixWithin[[1]]+FixWithin[[2]])/2;

,

(* (pole center, current line center), (poleinterval) *)
FixWithin=IntervalIntersec[IntervalIntersec[{Tmp[[1,1]],MyCenter},Tmp[[2]]],CurrIntervalLine];
CurrEvalPoint=(FixWithin[[1]]+FixWithin[[2]])/2;


];


CurrEvalPointCurrLine=RelateLinesPoint[CurrLine,line,CurrEvalPoint];
EvaluateCurrPoint[];

MyCenter=Tmp[[1,1]];
CurrLine=Tmp[[1,2]];
If[FEC[UseMobius]===True,CurrLineNoMobius=Tmp[[1,3]]];
,
(* Finite point *)
If[to>FixAt,
CurrEvalPoint=CurrIntervalLine[[2]],
CurrEvalPoint=CurrIntervalLine[[1]]
];
CurrEvalPointCurrLine=RelateLinesPoint[CurrLine,line,CurrEvalPoint];
EvaluateCurrPoint[];

If[FEC[SegmentationStrategy]==="Dynamic",
MyCenter=CurrEvalPoint;
];
If[FEC[SegmentationStrategy]==="Predivision",
If[to>FixAt,
MyCenter=FindNextCenterPointL[CurrEvalPoint,MySingularities],
MyCenter=FindNextCenterPointR[CurrEvalPoint,MySingularities]
];
];

CurrLine=GetLineRescaled[line,MyCenter,{MySingularities,MySingularitiesImaginary}];
If[FEC[UseMobius]===True,CurrLineNoMobius=GetLineRescaled[line,MyCenter,{MySingularities,MySingularitiesImaginary},True]];
];

Currbcs={
line/.x->CurrEvalPoint,
CurrEval
};

If[!FEC["EstimateError"]===False,
CurrbcsError={line/.x->CurrEvalPoint,CurrEvalError};
PrintError[];
];
];

(* Analytic continuation failed. *)
If[MultivaluedFail,
PrintWarning["The computation will be aborted, and the last line segment will be returned."];
Done=True;
];

RepeatingSegment=False;
If[FEC[SegmentationStrategy]=="Predivision"&&KeyExistsQ[DiffExpConfiguration,AccuracyGoal]&&DiffExpConfiguration["AccuracyGoalValidate"]==="After",
If[CurrError>10^-FEC[AccuracyGoal],
ExpansionOrderVal+=IExpansionOrderIncrease2;
PrintInfo["The estimated error of the results is lower than the requested AccuracyGoal. The expansions will be repeated at the order ",ExpansionOrderVal,"."][1];
(* Reload variables for the computation of the segment *)
{Currbcs,CurrbcsError,bcs,CurrLine,MyCenter,FixAt,CurrErrorAcc,CurrErrorAccs}=CurrStatusBackup;
(* Drop the expansion matrices *)
KeyDropFrom[DEqnMatricesExpanded,CurrLine];
(* Decrease counter *)
SegmentCounter-=1;
(* We are not done yet. *)
Done=False;
RepeatingSegment = True;
,
(* If we had reset the value of expansion order, we put it back. *)
If[ExpansionOrderVal!=FEC[ExpansionOrder],
ExpansionOrderVal=FEC[ExpansionOrder];
];
];
];

If[!RepeatingSegment,
(* Clear up some memory. *)
ClearMatrices[CurrStatusBackup[[4]]];
];

];

PrintInfo["Finished integration of ",SegmentCounter-1," segments in ",AbsoluteTime[]-TimeStart0//N," seconds."][1];
PrintDebug["Performed ",SegmentCounter-SegmentsToIntegrate," additional expansions due to changing the expansion order."][1];

If[MultivaluedFail,
LineReturn=FailedLine,
LineReturn=line/.x->to;
];

If[SaveExpansions===True,
If[!FEC["EstimateError"]===False,
{{LineReturn,CurrEval,CurrErrorAccs},AllIntegrationData},
{{LineReturn,CurrEval},AllIntegrationData}
]
,
If[!FEC["EstimateError"]===False,
{LineReturn,CurrEval,CurrErrorAccs},
{LineReturn,CurrEval}
]
]
]

(* Get a line segment centered at at_ *)
GetLineRescaled[line_Association,at_,{signsproj_,signsim_},nomobius_:False]:=Block[{$MaxExtraPrecision=1000},If[UseMobiusVal===True&&nomobius===False,
Module[{t1l,t1r,tmp},
t1l=Select[signsproj,#<at&]//Last;
t1r=Select[signsproj,#>at&]//First;

(tmp=Together[#];Collect[Numerator[#],x]/Collect[Denominator[#],x])&/@((line/.x->GetMobius[{t1l,at,t1r}]))/.x->x/FEC[RadiusOfConvergence]//SetPrecision[#,2FEWorkingPrecision]&
],
Module[{t1,tmp,mynearest},
t1l=Select[signsproj,#<at&]//Last;
t1r=Select[signsproj,#>at&]//First;
t1=Min[at-t1l,t1r-at];

(tmp=Together[#];Collect[Numerator[#],x]/Collect[Denominator[#],x])&/@(((Normal[line]/.x->at+x #/.x->x/FEC[RadiusOfConvergence]//SetPrecision[#,2FEWorkingPrecision]&//Expand//Association)&@t1))
]
]];

(* Functions for deriving center points in the predivision segmentation strategy. *)
GetMobiusCPL[{-\[Infinity],zbound_,zmax_}]:=(-zbound+k zbound+2 zmax)/(1+k)/.k->FEC[DivisionOrder];
GetMobiusCPL[{zmin_,zbound_,\[Infinity]}]:=(zbound+k zbound-2 zmin)/(-1+k)/.k->FEC[DivisionOrder];
GetMobiusCPL[{zmin_,zbound_,zmax_}]:=(zbound zmax+k zbound zmax+zbound zmin-k zbound zmin-2 zmax zmin)/(2 zbound-zmax+k zmax-zmin-k zmin)/.k->FEC[DivisionOrder];
GetMobiusCPR[{-\[Infinity],zbound_,zmax_}]:=(zbound+k zbound-2 zmax)/(-1+k)/.k->FEC[DivisionOrder];
GetMobiusCPR[{zmin_,zbound_,\[Infinity]}]:=(-zbound+k zbound+2 zmin)/(1+k)/.k->FEC[DivisionOrder];
GetMobiusCPR[{zmin_,zbound_,zmax_}]:=(zbound zmax-k zbound zmax+zbound zmin+k zbound zmin-2 zmax zmin)/(2 zbound-zmax-k zmax-zmin+k zmin)/.k->FEC[DivisionOrder];

GetCPLRep[MyEq_]:=Block[{rs},
rs=Cases[MyEq,xnew==a_|s==a_]/.Equal->Rule;
xnew//.rs
];
GetCPL[{-\[Infinity],zbound_,zmax_},k2_:Null]:=Block[
{MyEq,k=If[k2===Null,DivisionOrderVal,k2]},
MyEq=zmax\[Element]Reals&&zbound<zmax&&k>=1&&s==(-k zbound+k zmax)/(1+k)&&xnew==-s+zmax;
GetCPLRep[MyEq]
];
GetCPL[{zmin_,zbound_,\[Infinity]},k2_:Null]:=Block[
{MyEq,k=If[k2===Null,DivisionOrderVal,k2]},
MyEq=zmin\[Element]Reals&&zbound>zmin&&k>1&&s==(k zbound-k zmin)/(-1+k)&&xnew==s+zmin;
GetCPLRep[MyEq]
];
GetCPL[{zmin_,zbound_,zmax_},k2_:Null]:=Block[
{MyEq,k=If[k2===Null,DivisionOrderVal,k2]},
MyEq=zmin\[Element]Reals&&zmax>zmin&&((zmin<zbound<(zmax+zmin)/2&&((1<=k<=(zmax-zmin)/(-2 zbound+zmax+zmin)&&s==(-k zbound+k zmax)/(1+k))||(k>(zmax-zmin)/(-2 zbound+zmax+zmin)&&s==(k zbound-k zmin)/(-1+k))))||((zmax+zmin)/2<=zbound<zmax&&k>=1&&s==(-k zbound+k zmax)/(1+k)))&&xnew==(s+k zbound)/k;
GetCPLRep[MyEq]
];
GetCPR[{-\[Infinity],zbound_,zmax_},k2_:Null]:=Block[
{MyEq,k=If[k2===Null,DivisionOrderVal,k2]},
MyEq=zmax\[Element]Reals&&zbound<zmax&&k>1&&s==(-k zbound+k zmax)/(-1+k)&&xnew==-s+zmax;
GetCPLRep[MyEq]
];
GetCPR[{zmin_,zbound_,\[Infinity]},k2_:Null]:=Block[
{MyEq,k=If[k2===Null,DivisionOrderVal,k2]},
MyEq=zmin\[Element]Reals&&zbound>zmin&&k>=1&&s==(k zbound-k zmin)/(1+k)&&xnew==s+zmin;
GetCPLRep[MyEq]
];
GetCPR[{zmin_,zbound_,zmax_},k2_:Null]:=Block[
{MyEq,k=If[k2===Null,DivisionOrderVal,k2]},
MyEq=zmin\[Element]Reals&&zmax>zmin&&((zmin<zbound<=(zmax+zmin)/2&&k>=1&&s==(k zbound-k zmin)/(1+k))||((zmax+zmin)/2<zbound<zmax&&((1<=k<=(-zmax+zmin)/(-2 zbound+zmax+zmin)&&s==(k zbound-k zmin)/(1+k))||(k>(-zmax+zmin)/(-2 zbound+zmax+zmin)&&s==(-k zbound+k zmax)/(-1+k)))))&&xnew==-((s-k zbound)/k);
GetCPLRep[MyEq]
];

FindNextCenterPointL[xbc_,singsproj_]:=Module[{xl,xr},
xl=Select[singsproj,#<xbc&]//Last;
xr=Select[singsproj,#>xbc&]//First;
If[FEC[UseMobius]===True,GetMobiusCPL[{xl,xbc,xr}],GetCPL[{xl,xbc,xr}]]
];
FindNextCenterPointR[xbc_,singsproj_]:=Module[{xl,xr},
xl=Select[singsproj,#<xbc&]//Last;
xr=Select[singsproj,#>xbc&]//First;
If[FEC[UseMobius]===True,GetMobiusCPR[{xl,xbc,xr}],GetCPR[{xl,xbc,xr}]]
];

(* Get intervals in the dynamic segmentation strategy. *)
GetMatricesPrecisionDistance[line_Association]:=Module[{DiffCoeffs,MaxVariation,SmallestCanGo,MaxDisc},
If[!NumericQ[FEC[AccuracyGoal]],
ReportError["Accuracy goal is not given as a number."];
];

DiffCoeffs={GetLargestTerm[line]}/.(a_:1)x^(b_:1):>{Abs@a,b};

If[DiffCoeffs==={-\[Infinity]},
Global`DebugData={line,DEqnMatricesExpanded[line]};
ReportError["Could not determine variation in the expanded matrices. Suggestions: 1. Decreasing \"ExpansionOrder\" (currently " <>ToString[ExpansionOrderVal]<>".) 2. Increasing \"ChopPrecision\" (currently " <>ToString[FEC[ChopPrecision]]<>".) 3. Decreasing \"RadiusOfConvergence\" (currently " <>ToString[FEC[RadiusOfConvergence]]<>".)"];
];

MaxVariation=First[DiffCoeffs];

SmallestCanGo=Block[{eps=10^-DigitsNeeded,Const=MaxVariation[[1]],Ord=MaxVariation[[2]]},
If[OddQ[ExpansionOrderVal],
{
Root[eps(-1)+Const #1^MaxVariation[[2]]&,1],
Root[eps(-1)+Const #1^MaxVariation[[2]]&,2]
}
,
{
Root[eps(-1)+Const #1^MaxVariation[[2]]&,1]
}
]
];

SmallestCanGo=Min[Abs/@SmallestCanGo];

SmallestCanGo
];

(* Provides a number of consistency checks, and reparametrizes boundary conditions. *)
CheckBoundaryConditionsAndReparametrize[bcs3_,line_Association]:=Module[{bcs2,bcs={Null,Null},lrln,lrln2,FixAt,zerlim,linerelser,tmp},
bcs2=bcs3;

If[DependsQ[line,x^(k_:1)/;(k!=1&k!=-1)],
ReportError["Non-linear line segments are currently not supported!"];
];
If[Or@@(!DependsQ[Keys@bcs2[[1]],#]&/@ExternalScalesVal),
Global`DebugData={Keys@bcs2[[1]],ExternalScalesVal};
ReportError["The point/line where the boundary conditions are defined does not fix all kinematic invariants and masses!"];
];
If[(IsPoint[bcs2[[1]]])&&DependsQ[bcs2[[2]]//Normal,x],
ReportError["The boundary terms that are provided depend on the line parameter ",x,", but the second argument does not."];
];
If[IsLine[bcs2[[1]]],
If[!(DeleteDuplicates@Flatten@MapAt[Head,bcs2[[2]]/."?"->O[x],{All,All}])==={SeriesData},
ReportError["Line depends on x but boundary data is not given as a series."];
]
];
If[!(Dimensions[bcs2[[2]]][[1]]===NumIntegrals),
ReportError["The number of entries in the boundary conditions does not match the size of the system."];
];
If[!(Dimensions[bcs2[[2]]][[2]]>=EpsilonOrderVal+1),
ReportError["Not enough orders in \[Epsilon] are given in the boundary conditions. Try running PrepareBoundaryConditions[...] again."];
];
bcs2[[2]]=bcs2[[2]][[Range@NumIntegrals,Range@(EpsilonOrderVal+1)]];


lrln=RelateLines[line,bcs2[[1]],True];

If[lrln===False,
Global`DebugData={bcs2,line};
ReportError["Chosen boundary point does not lie on line. This error might also occur when the ChopPrecision is set too high."];
];

bcs2[[2]]=MapAt[If[!Accuracy[#]===\[Infinity],SetPrecision[#,FEWorkingPrecision],#]&,bcs2[[2]],{All,All}];

zerlim=Limit[lrln,x->0]//PChop;
If[zerlim===0,
FixAt=0;

If[!DependsQ[bcs2[[1]],x],
(* Point that happens to lie at origin *)
bcs[[1]]=line/.x->FixAt;
bcs[[2]]=MapAt[SeriesAlways[#,{x,0,0},2]&,bcs2[[2]],{All,All}];
bcs[[2]]=bcs[[2]]/.(a_:1)"?"+O[x]^(1/2)->"?";
,

(* Line segment around origin *)
lrln2=RelateLines[bcs2[[1]],line];

If[(Sign@Limit[D[lrln2,x],x->0])===-1,
ReportError["Asymptotic boundary conditions should be oriented in the same direction as the integration line."];
];

bcs[[1]]=bcs2[[1]]/.x->lrln2;
linerelser=x->(Series[lrln2,{x,0,ISeriesChangeCoefficient ExpansionOrderVal},Assumptions->x>0]);
bcs[[2]]=Assuming[x>0,bcs2[[2]]/.linerelser/.Logx->Log[(linerelser[[2]]//Normal)/.x->yy]];

tmp=bcs[[2]]//GetCases[#,Log[_]]&;
tmp=#->Normal[Series[#,{yy,0,ExpansionOrderVal},Assumptions->yy>0]]&/@tmp;
tmp[[All,2]]=(tmp[[All,2]]/.{
Log[a_ yy]/;a>0:>Log[a]+Log[yy],
Log[a_ yy]/;a<0:>Log[-a]+Log[yy]
}/.Log[yy]->Logx/.yy->x)(*+O[x]^ExpansionOrderVal*);

bcs[[2]]=SafeReplaceSeries11[bcs[[2]],tmp]//Quiet[N[#,FEC[WorkingPrecision]]]&;

If[DependsQ[bcs[[2]],Log[_]],
Global`DebugData=SExpand@bcs[[2]];
ReportError["Error rescaling boundary conditions."];
];
];

,

If[DependsQ[Normal[lrln],x],
ReportError["Boundary conditions given on asymptotic limit that is not centered at current line."];
];

(* From hereon we can assume we are fixing at a point *)
bcs[[1]]=line/.x->lrln;
bcs[[2]]=bcs2[[2]];
FixAt=lrln;
];

{bcs,FixAt}
];

GetMatchingPoint[line_Association,bcsline_]:=Module[{lrln,zerlim,FixAt},
lrln=RelateLines[line,bcsline,True];

If[lrln===False,
Global`DebugData={bcsline,line};
ReportError["GetMatchingPoint: Internal error"];
];

If[DependsQ[lrln,x],
zerlim=Limit[lrln,x->0]//PChop;

If[zerlim===0,
FixAt=0;,
ReportError["GetMatchingPoint: Internal error."];
];
,
FixAt=lrln;
];

FixAt
];

(* Removes multiple occurrences of theta functions. *)
SetAttributes[Project\[Theta]s,Listable];
Project\[Theta]s[Expr_,f_:Expand]:=Module[{
\[Theta]mPart,
\[Theta]pPart
},

If[Length[GetCases[Expr,\[Theta]p|\[Theta]m]]===0,
f[Expr]//SExpand,
\[Theta]mPart=(Expr/.\[Theta]p->0/.\[Theta]m->1);
\[Theta]pPart=(Expr/.\[Theta]m->0/.\[Theta]p->1);
(f[\[Theta]pPart+\[Theta]mPart]//(PChop@*SExpand))((*1/2\[Theta]m+1/2\[Theta]p*)1/2)+(f[\[Theta]pPart-\[Theta]mPart]//(PChop@*SExpand))(1/2 \[Theta]p-1/2 \[Theta]m)
]
];

MatrixLogxInverse[Mat_]:=Module[{MaxLogxPower=(Mat//Dimensions//First)-1(*Append[Cases[Mat,Logx^(k_:1)\[RuleDelayed]k,Infinity],0]//Max*),BB,AAA,AA},
AAA=Mat//DiffExp`Private`SExpand;
AA[0]=AAA/.Logx->0;
BB[0]=Inverse[AA[0](*,Method\[Rule]"DivisionFreeRowReduction"*)];
Do[
AA[mm]=Coefficient[AAA,Logx^mm](*AAA-(AAA/.Logx^k_/;(k===mm)\[RuleDelayed]0)*)(*AAA/.Logx^k_/;!(k===mm)\[RuleDelayed]0*)(*Coefficient[AAA,Logx^mm]*);
BB[mm]=-BB[0] . (Sum[AA[jj] . BB[mm-jj],{jj,1,mm}])//DiffExp`Private`SExpand
,{mm,1,MaxLogxPower}];
Sum[BB[mm]Logx^mm,{mm,0,MaxLogxPower}]//DiffExp`Private`SExpand
];

IntegrateSystem[bcs2:_List:"?",line2_Association|line2_List,opts2_:{}]:=Module[{bcs,line,lrln,lrln2,BCSRelevant,relevantinds,IgnorePositions,CurrBlock,HomogeneousEquation,Solns,MtildeMat,GMat,FMat,FMatInv,FMatInvBMat,BMat,CrossC,bVec,IntegrationData,fGeneral,FixAt,BoundaryEqns1,BoundaryEqns2,boundarysols,cIndices,Cmat,Cb,cpivs,csol,NewResults,Wronsk,ll,FMat2,NMat,HomogeneousEquation2,MtildeMat2,NMat2,Solns2,Wronsk2,WronskInvPrime,WWinvprimeprod,WronskInv,opts=opts2,DEqnMatricesExpandedCopy,TurnOffPade,MyN,MatricesMSupj,nthOrderDifferentialEquations,TmpSols,HighestOrderDifferentialEquationPosition,SolveFrom,nthOrderDifferentialEquationsSolutions,MtildeMatrix,bSupjVecs,MyHomogeneousSolutions,MyNumberOfSolutions,MyInhomogeneousTerm,VanishingTerms,csCurr,OverdeterminedEqns,CsPartSol,CsNullVectors,CsGeneralSol,CsReps,DerivativeVec,BDerVec,LineRat,csFreedom,CouldntSolve,xAdd,IndeterminatesRemaining,VanishingTermsCurr,LogsPresent,AlgebraicRootsPresent,TmpSolutionsNormal,MatricesMSupjExp,InhomPlaceHolder,MtildeInv},

If[line2[[0]]===List,line=line2//Association//KeySort,line=line2//KeySort];

If[Or@@(!DependsQ[Keys@line,#]&/@ExternalScalesVal),
ReportError["The line does not fix all kinematic invariants and masses!"];
];

If[!MemberQ[opts,"TransportToCall"],
PrintInfo["Obtaining series solutions along provided line.."][1];
If[Accuracy[line]<FEWorkingPrecision,
line=line//Normal//SetPrecision[#,2FEWorkingPrecision]&//Association;
PrintWarning["Accuracy of the line/point is lower than the working precision. The precision has been artificially increased."];
];
];

TurnOffPade[]:=If[FEC[UsePade]===True&&MemberQ[opts,"TransportToCall"],
PrintWarning["Due to the presence of free parameters Pade approximants will be disabled. You will have to manually enable them again in the configuration by setting UsePade -> True!"];
DiffExpConfiguration[UsePade]=False;
];

If[!MemberQ[opts,"DecreaseOrderBy1"],
BufferedData=Association[{}];
MyWronsk=Association[{}];
MyWronskDetInv=Association[{}];
];

(* To deal with the output of SaveExpansions = True *)
If[MatchQ[bcs2,{{a_Association,__},_}],
bcs=bcs2[[1]];,
bcs=bcs2;
];

If[!(bcs2==="?"),

{bcs,FixAt}=CheckBoundaryConditionsAndReparametrize[bcs,line];

PrintDebug["Boundary conditions are given by:"][2];
PrintDebug["Line: ",bcs[[1]]//Normal//N//Association][2];
PrintDebug["Conditions: ",bcs[[2]]//Normal//N][2];
PrintDebug["Fixing boundary conditions at x = ",FixAt][2];

,

TurnOffPade[];
];

If[!Complement[ExternalScalesVal,Keys[line]]==={},
ReportError["Line does not fix all kinematic variables!"];
];

PrepareAnalyticContinuation[line];

If[!MemberQ[opts,"TransportToCall"],
(* We do this because the user might have aborted TransportTo while using the option AccuracyGoal. *)
ExpansionOrderVal=FEC[ExpansionOrder];
ClearMatrices[];
];

PrepareMatrices[line];
InitializeIntegrationSequence[line];

IntegrationData=Association[{}];

DEqnMatricesExpandedCopy=DEqnMatricesExpanded[line];

If[MemberQ[opts,"DecreaseOrderBy1"],
Do[DEqnMatricesExpandedCopy[lind]=DecreaseSeriesOrderBy[DEqnMatricesExpandedCopy[lind],IDecreaseOrderByErrorPrecise+MaxCouplingOrder],{lind,0,EpsilonOrderVal}];
];

Do[
PrintInfo["Currently at order: \[Epsilon]^",epsord,"."][2];

IntegrationDataTab=Table[IntegrationData[{ind,myeps}],{ind,NumIntegrals},{myeps,0,epsord-1}];

If[epsord>0,
bVec1=DEqnMatricesExpandedCopy[1] . IntegrationDataTab[[All,epsord-1+1]];
];
If[epsord>1,
bVecRest=Sum[DEqnMatricesExpandedCopy[lind] . IntegrationDataTab[[All,epsord-lind+1]]//SExpand,{lind,2,epsord}];
];

Do[
PrintInfo["Integrating integral(s) ",intind, " at order \[Epsilon]^",epsord,"."][3];

PrintDebug["Getting inhomogeneous terms."][3];

jinds=Complement[Range[NumIntegrals],intind];
IntegrationDataTab0jind=Table[IntegrationData[{ind,myeps}],{ind,jinds},{myeps,0,epsord}];
bVec0=SExpand[DEqnMatricesExpandedCopy[0][[intind,jinds]] . IntegrationDataTab0jind[[All,epsord+1]]];
Which[epsord===0,
bVec=bVec0//SExpand;,
epsord===1,
bVec=bVec0+bVec1[[intind]]//SExpand;,
epsord>1,
bVec=bVec0+bVec1[[intind]]+bVecRest[[intind]]//SExpand;
];

PrintDebug["Done."][3];
(*------------------------------------------------------------------------------------------------------------------------------*)
Which[
(* Integration of integral without homogeneous components *)

Length[intind]===1&&PChop[DEqnMatricesExpanded[line][0][[intind,intind]]]==={{0}},

cIndices={Subscript[c, 1]};

If[PChop[bVec]==={0},
fGeneral={Subscript[c, 1]+O[x]^(ExpansionOrderVal+1)};
,
fGeneral={DiffExpIntegrate[bVec[[1]],x]+Subscript[c, 1]+O[x]^(ExpansionOrderVal+1)(* +O[x]^(ExpansionOrderVal+1) is added because otherwise it might happen that fGeneral is not a series. *)};
];

,FEC[IntegrationStrategy]==="Default",
(* Default integration strategy*)

If[epsord===0&&!KeyExistsQ[BufferedData,intind],
If[Length[intind]>1,
PrintInfo["Combining differential equations: ",intind->intind[[1]],"."][3];
];
ll=intind//Length;
{HomogeneousEquation,MtildeMat}=CombineDifferentialEquationsHomogeneous[
If[FEC["HomogeneousSolve"]==="Expand",
DEqnMatricesExpanded[line][0][[intind,intind]],
DEqnMatricesFactored[line][0][[intind,intind]]
]
,1];

PrintDebug["Found homogeneous differential equation: ",HomogeneousEquation+O[x]^4//SN][3];

NMat=Table[
If[ind<ll,UnitVector[ll,ind+1],-HomogeneousEquation[[Range@ll]]]
,{ind,ll}];

PrintDebug["Deriving solutions..."][3];
Solns=FrobeniusSolutions[HomogeneousEquation];
PrintDebug["All homogeneous solutions found..."][3];
PrintDebug["Deriving period matrix..."][3];
Wronsk=Table[
SD[Solns[[iind]],Sequence@@CA[x,jind-1]]
,{jind,ll},{iind,ll}
]//SExpand;

If[(FEC["InvWronskSolver"]==="Auto"),
If[(DependsQ[Wronsk,Logx]),
CurrInvWronskSolver="Frobenius";,
CurrInvWronskSolver="Inverse";
];
,
CurrInvWronskSolver=FEC["InvWronskSolver"];
];

If[CurrInvWronskSolver==="Frobenius",
PrintDebug["Determining inverse Wronskian using the Frobenius method."][1];
{HomogeneousEquation2,MtildeMat2}=CombineDifferentialEquationsHomogeneous[
-NMat//Transpose,1];

NMat2=Table[
If[ind<ll,UnitVector[ll,ind+1],-HomogeneousEquation2[[Range@ll]]]
,{ind,ll}];

Solns2=FrobeniusSolutions[HomogeneousEquation2];

PrintDebug["Deriving inverse Wronskian."][3];

Wronsk2=Table[
SD[Solns2[[iind]],Sequence@@CA[x,jind-1]]
,{jind,ll},{iind,ll}
]//SExpand;

(* Cross-checking Wronskians *)
If[MemberQ[CurrCrosscheckFlags,"Wronskians"]===True,
PrintDebug["Cross-checking Wronskians."][1];
CrossC=(SD[Wronsk,x]-MatrixMultiplySExpand[NMat,Wronsk]//(CPChop@*SExpand))+O[x]^ICrossCheckVerifyResultOrder;
PrintDebug["Found: ",CrossC+O[x]^ICrossCheckPrintResultOrder//SN][3];
If[
!(SameQ@@Append[CrossC//Normal//Flatten,0])
,
ReportError["Cross-check failed."];
];

CrossC=(SD[Wronsk2,x]-MatrixMultiplySExpand[NMat2,Wronsk2]//(PChop@*SExpand))+O[x]^ICrossCheckVerifyResultOrder;
PrintDebug["Found: ",CrossC+O[x]^ICrossCheckPrintResultOrder//SN][1];
If[
!(SameQ@@Append[CrossC//Normal//Flatten,0])
,
ReportError["Cross-check failed."];
]
];

WronskInvPrime=Inverse[MtildeMat2] . Wronsk2//Transpose//SExpand;
PrintDebug["Deriving inverse Wronskian.."][3];
WWinvprimeprod=PChop@Normal@MatrixMultiplySExpand[WronskInvPrime,Wronsk];
PrintDebug["Deriving inverse Wronskian..."][3];
If[MemberQ[CurrCrosscheckFlags,"WronskInv"]===True,
If[DependsQ[(WWinvprimeprod//CPChop)+O[x]^ICrossCheckVerifyResultOrder//Normal,x],
Global`DebugData={WronskInvPrime,Wronsk,WWinvprimeprod};
ReportError["Warning, product of Wronskian inverse times Wronskian does not match identity. Try increasing \"ChopPrecision\" or \"WorkingPrecision\", or try decreasing \"ExpansionOrder\"."][1];
];
];
Global`DebugData={WWinvprimeprod};
WWinvprimeprod=WWinvprimeprod/. x^(k_:1):>0/.Logx->0;
WronskInv=PChop@MatrixMultiplySExpand[(WWinvprimeprod//Inverse),WronskInvPrime];
PrintDebug["Done."][3];
];

If[CurrInvWronskSolver==="Inverse",
WronskInv=Inverse[Wronsk,Method->"DivisionFreeRowReduction"];
];

If[CurrInvWronskSolver==="InverseLogx",
WronskInv=MatrixLogxInverse[Wronsk];
];

Check[
If[FEC["HomogeneousSolve"]==="Expand",
MtildeInv=Inverse[MtildeMat,Method->"DivisionFreeRowReduction",ZeroTest->(Normal[#]==0&)];,
MtildeInv=DiffExpSeries[Inverse[MtildeMat]//Together];
];
FMat=PChop@(MtildeInv . Wronsk//SExpand);
,
PrintWarning["Encountered numerical instability while inverting Mtilde. Turning off DivisionFreeRowReduction and trying again.."];
FMat=PChop@(Inverse[MtildeMat] . Wronsk//SExpand);
];

FMatInv=PChop@(MatrixMultiplySExpand[WronskInv,MtildeMat]);

(* Cross-checking FMat *)
If[MemberQ[CurrCrosscheckFlags,"PeriodMatrix"]===True,
PrintDebug["Cross-checking period matrix.."][1];
CrossC=SD[FMat,x]-MatrixMultiplySExpand[DEqnMatricesExpanded[line][0][[intind,intind]],FMat+O[x]^ICrossCheckVerifyResultOrder]//(CPChop@*SExpand);
Global`DebugData={FMat,DEqnMatricesExpanded[line][0][[intind,intind]],CrossC,MtildeMat,Wronsk};
PrintDebug["Found: ",CrossC+O[x]^ICrossCheckPrintResultOrder//SN][3];
If[
!(SameQ@@Append[CrossC//Normal//Flatten,0])
,
ReportError["Cross-check of period matrix failed"];
];
];

PrintDebug["Period matrix derived."][3];

BufferedData[intind]={FMat,FMatInv};
];

If[MemberQ[opts,"DecreaseOrderBy1"],
{FMat,FMatInv}=BufferedData[intind];
FMat=DecreaseSeriesOrderBy[FMat];
FMatInv=DecreaseSeriesOrderBy[FMatInv];
,
{FMat,FMatInv}=BufferedData[intind];
];

{FMat,FMatInv}=BufferedData[intind];

PrintDebug["Setting up general solution."][3];
BMat=1/Length@intind Table[bVec,{iind,intind//Length}]//Transpose;
cIndices=Table[Subscript[c, i],{i,intind//Length}];

GMat=MatrixMultiplySExpand[FMat,DiffExpIntegrate[MatrixMultiplySExpand[FMatInv,BMat]]+DiagonalMatrix[cIndices]]//PChop;

If[MemberQ[CurrCrosscheckFlags,"GeneralSolutionMatrix"]===True,
PrintDebug["Cross-checking GMat with differential equations."][1];
CrossC=SD[GMat,x]-MatrixMultiplySExpand[DEqnMatricesExpanded[line][0][[intind,intind]],GMat+O[x]^ICrossCheckVerifyResultOrder]-BMat//(CPChop@*SExpand);
Global`DebugData={FMat,GMat,FMatInv,BMat,DEqnMatricesExpanded[line][0][[intind,intind]],CrossC,MtildeMat,Wronsk};
PrintDebug["Found: ",CrossC+O[x]^ICrossCheckPrintResultOrder//SN][3];
If[
!(SameQ@@Append[CrossC+O[x]^ICrossCheckVerifyResultOrder//Normal//Flatten,0])
,
ReportError["Cross-check of solution matrix failed"];
];
];

fGeneral=Total[GMat//Transpose];

(*------------------------------------------------------------------------------------------------------------------------------*)
,FEC[IntegrationStrategy]==="VOP"||FEC[IntegrationStrategy]==="VariationOfParameters",

PrintDebug["Solving by variation of parameters. ",intind][3];

MyN=intind//Length;

If[epsord===0&&!KeyExistsQ[BufferedData,intind],
If[FEC["HomogeneousSolve"]==="Expand",
MatricesMSupj=PChop@NestList[SExpand[(SD[#,x]+MatrixMultiplySExpand[#,DEqnMatricesExpanded[line][0][[intind,intind]]])]&,IdentityMatrix[MyN],MyN];
,
MatricesMSupj=NestList[Together[(D[#,x]+# . DEqnMatricesFactored[line][0][[intind,intind]])]&,IdentityMatrix[MyN],MyN];
];

nthOrderDifferentialEquations=Table[
If[FEC["HomogeneousSolve"]==="Expand",
TmpSols=MatricesMSupj[[All,ind]]//Transpose//NullSpace[#,Method->"DivisionFreeRowReduction",Tolerance->10^-LinearSolveChopPrecisionVal]&;
,
TmpSols=MatricesMSupj[[All,ind]]//Transpose//NullSpace//Together;
];
TmpSols=Internal`DeleteTrailingZeros/@TmpSols;
TmpSols=DiffExpSeries[MinimalBy[TmpSols,Length]//First];
TmpSols/(TmpSols//Last)
,
{ind,MyN}
];

If[FEC["HomogeneousSolve"]==="Expand",
MatricesMSupj=DiffExpSeries[MatricesMSupj];
];

HighestOrderDifferentialEquationPosition=FirstPosition[Length/@nthOrderDifferentialEquations,Max[Length/@nthOrderDifferentialEquations]][[1]];
If[Length[nthOrderDifferentialEquations[[HighestOrderDifferentialEquationPosition]]]<MyN+1,
SolveFrom=Range@Length@nthOrderDifferentialEquations;
nthOrderDifferentialEquationsSolutions=FrobeniusSolutions/@nthOrderDifferentialEquations;
If[MyN==1,
If[FEC["HomogeneousSolve"]==="Expand",
MtildeMatrix=PChop@DiffExpSeries[MatricesMSupj[[All,SolveFrom[[1]]]][[Range[MyN],Range[MyN]]]];
,
MtildeMatrix=MatricesMSupj[[All,SolveFrom[[1]]]][[Range[MyN],Range[MyN]]];
];
,
MtildeMatrix={};
];
,
SolveFrom={HighestOrderDifferentialEquationPosition};

If[FEC["HomogeneousSolve"]==="Expand",
MtildeMatrix=PChop@DiffExpSeries[MatricesMSupj[[All,SolveFrom[[1]]]][[Range[MyN],Range[MyN]]]];
,
MtildeMatrix=MatricesMSupj[[All,SolveFrom[[1]]]][[Range[MyN],Range[MyN]]];
];
nthOrderDifferentialEquationsSolutions=ConstantArray[Null,Length@nthOrderDifferentialEquations];
nthOrderDifferentialEquationsSolutions[[HighestOrderDifferentialEquationPosition]]=FrobeniusSolutions@nthOrderDifferentialEquations[[HighestOrderDifferentialEquationPosition]];
];

PrintDebug["Determining Wronskian matrices."][3];

Table[
MyHomogeneousSolutions=nthOrderDifferentialEquationsSolutions[[myintind]];

MyWronsk[{intind,myintind}]=Table[
SD[MyHomogeneousSolutions[[mysolind]],Sequence@@ConstantArray[x,diffind]]
,{diffind,0,Length[MyHomogeneousSolutions]-1},{mysolind,Length[MyHomogeneousSolutions]}];

PrintDebug["Determining 1/WronskianDet: ",myintind][3];
MyWronskDetInv[{intind,myintind}]=DiffExpSeries[1/(MyWronsk[{intind,myintind}]//Det//SExpand),ExpansionOrderVal];
PrintDebug["Done determining 1/WronskianDet: ",myintind][3];
,{myintind,SolveFrom}
];

BufferedData[intind]={MatricesMSupj,nthOrderDifferentialEquations,nthOrderDifferentialEquationsSolutions,SolveFrom,MtildeMatrix};
];

{MatricesMSupj,nthOrderDifferentialEquations,nthOrderDifferentialEquationsSolutions,SolveFrom,MtildeMatrix}=BufferedData[intind];

PrintDebug["Determining b's.."][3];
bSupjVecs=FoldList[SExpand[#2 . bVec+SD[#1,x]]&,ConstantArray[0,MyN],Delete[MatricesMSupj,-1]];

PrintDebug["Setting up general solutions. ",intind][3];
fGeneral=Table[
MyHomogeneousSolutions=nthOrderDifferentialEquationsSolutions[[myintind]];
MyNumberOfSolutions=MyHomogeneousSolutions//Length;
MyInhomogeneousTerm=nthOrderDifferentialEquations[[myintind]] . bSupjVecs[[All,myintind]][[Range@(MyNumberOfSolutions+1)]];


SExpand@Sum[
MyWi=MyWronsk[{intind,myintind}];
MyWi[[All,ind]]=Append[ConstantArray[0,MyNumberOfSolutions-1],PlaceHolder];

If[MemberQ[opts,"DecreaseOrderBy1"],
MyWi=DecreaseSeriesOrderBy[MyWi];
];

(MyHomogeneousSolutions[[ind]](Subscript[c, myintind,ind]+DiffExpIntegrate[
MyWronskDetInv[{intind,myintind}]((MyWi//Det//SExpand)/.PlaceHolder->MyInhomogeneousTerm//SExpand)//SExpand
])//SExpand)//SExpand

,{ind,MyHomogeneousSolutions//Length}]

,{myintind,SolveFrom}
];

PrintDebug["Done. ",intind][3];

If[Length[SolveFrom]>1,
VanishingTerms=SExpand@(SD[fGeneral,x]-DEqnMatricesExpanded[line][0][[intind,intind]] . fGeneral-bVec);

IndeterminatesRemaining=csCurr=GetCases[fGeneral,Subscript[c, i_,j_]];

If[!DeleteDuplicates[Normal[VanishingTerms]]==={0},
xAdd=-1;

While[Length[IndeterminatesRemaining]>Length[fGeneral],
VanishingTermsCurr=Series[VanishingTerms,{x,0,xAdd}];

PrintDebug["Reducing number of indeterminate constants, considering terms up to O[x]^",xAdd][3];
OverdeterminedEqns=Flatten[Flatten[LogxCoeffList/@VanishingTermsCurr][[All,3]]];

If[Length[OverdeterminedEqns]>0,

{Cmat,Cb}={#[[2]],-#[[1]]}&@CoefficientArrays[DeleteCases[OverdeterminedEqns,True],csCurr];

CsPartSol=LinearSolve[Cmat,Cb,ZeroTest->(N[LSPChop@Expand@Normal[#1],LinearSolveChopPrecisionVal]==0&)];

CsNullVectors=Cmat//NullSpace[#,Tolerance->10^-LinearSolveChopPrecisionVal]&;
CsGeneralSol=CsPartSol+Sum[CsNullVectors[[ind]]Subscript[c, ind],{ind,Length[CsNullVectors]}]//SExpand;

CsReps=Thread[csCurr->CsGeneralSol]//PChop;

IndeterminatesRemaining=GetCases[CsGeneralSol,Subscript[c, __]];

];

xAdd+=1;
];

If[Length[IndeterminatesRemaining]<Length[fGeneral],
Global`DebugData={Cmat,Cb,CsGeneralSol};
ReportError["There was an error in obtaining the solutions for integrals ",intind," at order ",epsord," using the \"VOP\" strategy. Try decreasing the value of the option ChopPrecision or increasing the WorkingPrecision."];
];

fGeneral=fGeneral/.CsReps;

,

fGeneral=fGeneral/.Table[csCurr[[ind]]->Subscript[c, ind],{ind,Length@csCurr}];
];

,

(* We can currently put fGeneral[[1]], as SolveFrom is either one element, or all elements. *)
DerivativeVec=Table[SD[fGeneral[[1]],Sequence@@CA[x,jind-1]],{jind,intind//Length}]//SExpand;
(* But for BDerVec we should choose SolveFrom[[1]] *)
BDerVec=bSupjVecs[[All,SolveFrom[[1]]]][[Range@MyN]];

Check[
If[FEC["HomogeneousSolve"]==="Expand",
MtildeInv=Inverse[MtildeMatrix,Method->"DivisionFreeRowReduction",ZeroTest->(Normal[#]==0&)];,
MtildeInv=DiffExpSeries[Inverse[MtildeMatrix]//Together];
];
fGeneral=PChop@(MtildeInv . (DerivativeVec-BDerVec)//SExpand);
,
PrintWarning["Encountered numerical instability while inverting Mtilde. Turning off DivisionFreeRowReduction and trying again.."];
fGeneral=PChop@(Inverse[MtildeMatrix] . (DerivativeVec-BDerVec)//SExpand);
];

fGeneral=fGeneral/.Thread[GetCases[fGeneral,Subscript[c, i_,j_]]->Table[Subscript[c, ind],{ind,MyN}]];

];

cIndices=GetCases[fGeneral,Subscript[c, i_]];

];

(*------------------------------------------------------------------------------------------------------------------------------*)

(* Code for fixing boundary conditions. *)
If[!(bcs2==="?"),
PrintDebug["General solution found. Fixing the indeterminates from boundary conditions."][2];

BCSRelevant=bcs[[2]][[intind]][[All,epsord+1]];
IgnorePositions=Flatten[Position[BCSRelevant,"?"]];
relevantinds=Complement[Range@Length[intind],IgnorePositions];
BCSRelevant=BCSRelevant[[relevantinds]];

If[FixAt===0,
BoundaryEqns1=(PChop(*Chop[#,10^-35]&*)@*SExpand)/@(fGeneral[[relevantinds]]-BCSRelevant);


If[
!SameQ[Append[BoundaryEqns1[[All,0]],SeriesData]],
ReportError["Internal bug while fixing the solutions from the boundary data."];
];

BoundaryEqns2=#==0&/@Flatten[{
#[[3]]/.Logx->0,
Table[Coefficient[#[[3]],Logx^kind],{kind,1,IMaxLogOrder}]
}&/@BoundaryEqns1];


,

BoundaryEqns1=Table[Sum[
cIndices[[ind]]SEval[SApply[Coefficient[#,cIndices[[ind]]]&,term],FixAt]
,
{ind,cIndices//Length}
]+SEval[term/.(#->0&/@cIndices),FixAt],{term,fGeneral[[relevantinds]]}]-BCSRelevant;

BoundaryEqns2=#==0&/@Flatten[BoundaryEqns1];
];

BoundaryEqns2=DeleteCases[BoundaryEqns2,True]//Expand;

If[!BoundaryEqns2==={},
PrintDebug["Boundary equations are: "][3];
PrintDebug[BoundaryEqns2//N//R[c->"c"]][3];

{Cmat,Cb}={#[[2]],-#[[1]]}&@CoefficientArrays[BoundaryEqns2,cIndices];

CouldntSolve=False;
If[!MemberQ[BoundaryEqns2,False],
Check[csol=LinearSolve[Cmat,Cb,ZeroTest->(N[LSPChop@Expand@Normal[#1],LinearSolveChopPrecisionVal]==0&)];
,CouldntSolve=True;];
,CouldntSolve=True;];

If[CouldntSolve,
Global`DebugData={BMat,fGeneral[[relevantinds]],BoundaryEqns1,BoundaryEqns2,BCSRelevant,Cmat,Cb,MtildeMat,Wronsk,WronskInv,WronskInvPrime,bVec,FMat,FMatInv,GMat,csol};
ReportError["Boundary conditions cannot be matched to general solution for integral(s): ",intind];
];

PrintDebug["Solutions: ",Thread[(ToString/@cIndices)->N[csol]]][2];

csFreedom=Cmat//NullSpace[#,Method->"DivisionFreeRowReduction",Tolerance->10^-LinearSolveChopPrecisionVal]&;
If[Length[csFreedom]>0,
PrintWarning["Not enough boundary data was provided for integral(s): ",intind," at epsilon order ",epsord,"."];
PrintWarning["Introducing free parameters: ",Table[Subscript[Global`c, epsord,intind,i],{i,Length@csFreedom}]][1];
csol=csol+Sum[csFreedom[[nullvecind]] Subscript[Global`c, epsord,intind,nullvecind],{nullvecind,Length@csFreedom}];
TurnOffPade[];
];

CsReps=Thread[cIndices->csol]//PChop;

fGeneral=fGeneral/.CsReps//SExpand;

,

If[Length[cIndices]>0,

If[!MemberQ[opts,"DecreaseOrderBy1"],
PrintWarning["Not enough boundary data was provided for integral(s): ",intind," at epsilon order ",epsord,"."];
PrintWarning["Introducing free parameters: ",cIndices/.Subscript[c, i_]:>Subscript[Global`c, epsord,intind,i]][1];
];

TurnOffPade[];

fGeneral=fGeneral/.Subscript[c, i_]:>Subscript[Global`c, epsord,intind,i]//SExpand;

];
];

,

(* No boundary terms provided. Relabeling for current epsilon order *)
fGeneral=fGeneral/.Subscript[c, i_]:>Subscript[Global`c, epsord,intind,i]//SExpand;
];

If[MemberQ[CurrCrosscheckFlags,"GeneralSolution"]===True,
PrintDebug["General solution found. Cross-checking with differential equations."][1];
CrossC=SD[fGeneral,x]-DEqnMatricesExpanded[line][0][[intind,intind]] . fGeneral-bVec+O[x]^ICrossCheckVerifyResultOrder//(CPChop@*SExpand);
PrintDebug["Found: ",CrossC+O[x]^ICrossCheckPrintResultOrder//SN][3];
If[
!(SameQ@@Append[CrossC//Normal//Flatten,0])
,
ReportError["Cross-check failed"];
];
];

NewResults=Thread[Table[{iind,epsord},{iind,intind}]->(PChop@*SExpand)[fGeneral]];

AssociateTo[
IntegrationData,
NewResults
];

,{intind,IntegrationSequence}
];
,{epsord,0,EpsilonOrderVal}];

GiveMultivaluedError[]:=(
ReportError["After fixing the boundary conditions, the solutions on the current line segment contain multivalued functions. However, the current point is not recognized as a branch point in the configuration, so DiffExp can't perform the analytic continuation! Please add a prescription for the analytic continuation using the option \"DeltaPrescriptions\".",False];

MultivaluedFail=True;
);

If[MemberQ[CurrCrosscheckFlags,"SingularityCheck"]===True,
TmpSolutionsNormal=Values[IntegrationData]//Normal//Chop[#,10^-ICheckMultivaluedChop]&;
LogsPresent=DependsQ[TmpSolutionsNormal,Logx|Logx^_];
AlgebraicRootsPresent=DependsQ[TmpSolutionsNormal,(x^b_/;Denominator[b]>1)];

If[!CurrentSingularityHasIDeltaPrescription&&(AlgebraicRootsPresent||LogsPresent),
GiveMultivaluedError[];
];

If[CurrentSingularityHasIDeltaPrescription&&CurrentSingularityWasAddedFromSquareRoot&&LogsPresent,
GiveMultivaluedError[];
];
];

If[(AnalyticContinuationFailed===True)&&!MemberQ[opts,"TransportToCall"],
PrintWarning["Could not transfer i\[Delta]-prescriptions to line parameter on current segment. The results may only be valid in the direction (x > 0 or x < 0) where the boundary conditions were given."];
];

If[MemberQ[opts,"TransportToCall"],
Table[IntegrationData[{ind,epsord}],{ind,NumIntegrals},{epsord,0,EpsilonOrderVal}]
,
ClearMatrices[];
Table[ApplyAnalyticContinuation[IntegrationData[{ind,epsord}]]//Project\[Theta]s,{ind,NumIntegrals},{epsord,0,EpsilonOrderVal}]
]
];

End[];

EndPackage[];
